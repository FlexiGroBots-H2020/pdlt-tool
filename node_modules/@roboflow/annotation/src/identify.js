module.exports = function(text, extension) {
    var type = "unknown";
    var format = extension;

    var firstLine;
    if(text && text.length) {
        var firstLineEnd = text.indexOf("\n");
        if(firstLineEnd < 0) firstLineEnd = text.length;
        firstLine = text.substring(0, firstLineEnd);
    }

    if(!text || !text.length) {
        // empty annotation type is unknown
    } else if(
        text.indexOf('https://storage.labelbox.com') >= 0 ||
        text.indexOf('storage.googleapis.com/labelbox') >= 0 ||
        text.indexOf('https://api.labelbox.com') >= 0 ||
        text.indexOf('//app.labelbox.') >= 0 ||
        text.indexOf('//editor.labelbox') >= 0
    ) {
        type = "LabelBox";
        format = extension;
    } else if(
        text.indexOf("data_row") >= 0 &&
        text.indexOf("external_id") >= 0 &&
        text.indexOf("media_attributes") >= 0 &&
        text.indexOf("row_data") >= 0
    ) {
        type = "LabelBox2";
        format = extension;
    } else if(
        extension == "json" &&
        text.indexOf('featureId') >= 0 &&
        text.indexOf('schemaId') >= 0 &&
        text.indexOf('frameNumber') >= 0
    ) {
        type = "LabelBoxVideo";
        format = extension;
    } else if(
        extension == "json" &&
        text.indexOf('area') > 0 &&
        text.indexOf('iscrowd') > 0 &&
        text.indexOf('file_name') > 0 &&
        text.indexOf('image_id') > 0
    ) {
        type = "COCO";
        format = "json";
    } else if(
        extension == "json" &&
        text.indexOf('regions') > 0 &&
        text.indexOf('shape_attributes') > 0 &&
        text.indexOf('region_attributes') > 0
    ) {
        type = "VIA";
        format = "json";
    } else if(
        extension == 'json' &&
        text.indexOf('annotations') > 0 &&
        text.indexOf('label') > 0 &&
        text.indexOf('coordinates') > 0
    ) {
        type = "CreateML";
        format = "json";
    } else if(
        extension == 'json' &&
        text.indexOf('task_id') > 0 &&
        text.indexOf('objects_to_annotate') > 0 &&
        text.indexOf('attachment') > 0
    ) {
        type = "ScaleAI";
        format = "json";
    } else if(
        extension == 'json' &&
        text.indexOf('assets') > 0 &&
        text.indexOf('format') > 0 &&
        text.indexOf('regions') > 0 &&
        text.indexOf('version') > 0
    ) {
        type = "VOTTVideo";
        format = "json";
    } else if(
        extension == 'json' &&
        text.indexOf('asset') > 0 &&
        text.indexOf('format') > 0 &&
        text.indexOf('regions') > 0 &&
        text.indexOf('version') > 0
    ) {
        type = "VOTT";
        format = "json";
    } else if(
        extension == 'json' &&
        text.indexOf('schema_ref') > 0 &&
        (text.indexOf('darwin_json/2.0') > 0 || text.indexOf('darwin_json_2_0') > 0)
    ) {
        type = "V7Darwin";
        format = "json";
    } else if(
        extension == 'json' &&
        text.indexOf('annotations') > 0 &&
        text.indexOf('v7labs.com') > 0 &&
        text.indexOf('workview_url') > 0
    ) {
        type = "V7Labs";
        format = "json";
    } else if(
        extension  == 'json' &&
        text.indexOf("images") > 0 &&
        text.indexOf("filename") > 0 &&
        text.indexOf("x0") > 0 &&
        text.indexOf("x1") > 0 &&
        text.indexOf("y0") > 0 &&
        text.indexOf("y1") > 0 &&
        text.indexOf("probability") > 0
    ) {
        type = "Cogniac";
        format = "json";
    } else if(
        extension == 'xml' &&
        text.indexOf('<Leaf') > 0 &&
        text.indexOf('<Page') > 0 &&
        text.indexOf('BBox') > 0
    ) {
        type = "Marmot";
        format = "xml";
    } else if(extension == 'xml' && text.indexOf("<rotatedRect") > 0 && text.indexOf("<point") > 0) {
        type = "PKLot";
        format = "xml";
    } else if(extension == 'xml') {
        type = "RectLabel";
        format = "xml";
    } else if(extension == 'csv') {
        type = "CSV";
        format = "csv";
    } else if(extension == 'udacity') {
        type = "Udacity";
        format = "udacity2";
    } else if(extension == "tfrecord") {
        type = "Tensorflow";
        format = "tfrecord";
    } else if(
        extension == "txt" &&
        firstLine.match(/^\d+(\s-?(0?\.\d+|1(\.0+)?|-1(\.0+)?)){4,}/)
    ) {
        type = "YoloDarknet";
        format = "txt";
    } else if(
        extension == "txt" &&
        firstLine.match(/.+\s([0-9]+,[0-9]+,[0-9]+,[0-9]+,[0-9]+\s?)+/)
    ) {
        type = "YoloKeras";
        format = "txt";
    } else if(
        extension == "txt" &&
        firstLine.match(/.+,[0-9]*,[0-9]*,[0-9]*,[0-9]*,.+/)
    ) {
        // RetinaNet CSV... but labeled as txt
        type = "CSV";
        format = "csv";
    } else if(
        extension == "manifest" &&
        firstLine.indexOf("source-ref") >= 0 &&
        firstLine.indexOf("annotations") >= 0 &&
        firstLine.indexOf("class-map") >= 0
    ) {
        type = "Groundtruth";
        format = "manifest";
    } else if(
        extension == "json" &&
        text.indexOf("labelerLogin") >= 0 &&
        text.indexOf("classTitle") >= 0 &&
        text.indexOf("geometryType") >= 0
    ) {
        type = "Supervisely";
        format = "json";
    } else if(
        extension == "json" &&
        text.indexOf("shape_type") >= 0 &&
        text.indexOf("flags") >= 0 &&
        text.indexOf("points") >= 0 &&
        text.indexOf("imagePath") >= 0 &&
        text.indexOf("imageData") >= 0
    ) {
        type = "Labelme";
        format = "json";
    } else if(
        extension == "json" &&
        text.indexOf("type") >= 0 &&
        text.indexOf("classId") >= 0 &&
        text.indexOf("probability") >= 0 &&
        text.indexOf("points") >= 0
    ) {
        type = "SuperAnnotate";
        format = "json";
    } else if(
      extension == "txt" &&
      firstLine.match(/\w+\s\d+\.\d+\s\d+\.\d+\s\d+\.\d+\s\d+\.\d+/)
    ) {
      type = "OpenImage";
      format = "txt";
    } else if(
        extension == "json" &&
        text.indexOf("version") >= 0 &&
        text.indexOf("1.0") >= 0 &&
        text.indexOf("localization") >= 0 &&
        text.indexOf("labels") >= 0 &&
        text.indexOf("annotations") >= 0
    ) {
        type = "CloudAnnotations";
        format = "json";
    } else if(
        extension == "json" &&
        text.indexOf("version") >= 0 &&
        text.indexOf("captures") >= 0 &&
        text.indexOf("filename") >= 0 &&
        text.indexOf("annotations") >= 0 &&
        text.indexOf("label_name") >= 0 &&
        text.indexOf("annotation_definition") >= 0
    ) {
        type = "Unity";
        format = "json";
    } else if(
        extension == "txt" &&
        firstLine.match(/.+\.(jpg|jpeg|png|bmp|tif|tiff)/i) && // filename
        text.match(/^[0-9]+\n[0-9]+ [0-9]+ [0-9]+ [0-9]+ 0|1 0|1 0|1 0|1 0|1 0|1$/g) // number of annotations, then bbox
    ) {
        type = "WiderFace";
        format = "txt";
    } else if(
        extension == "json" &&
        text.indexOf("predictions") >= 0 &&
        text.indexOf("x") >= 0 &&
        text.indexOf("y") >= 0 &&
        text.indexOf("width") >= 0 &&
        text.indexOf("height") >= 0 &&
        text.indexOf("class") >= 0 &&
        text.indexOf("confidence") >= 0
    ) {
        type = "RoboflowPrediction";
        format = "json";
    }

    return {
        type: type,
        format: format
    };
};