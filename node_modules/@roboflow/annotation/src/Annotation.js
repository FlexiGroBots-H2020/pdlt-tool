/*jshint esversion:8*/
/*jshint -W069*/
var _ = typeof window != "undefined" && window && window._ || require('lodash');
var Handlebars;
const moment = require("moment");
const pluralize = require("pluralize");
const yaml = require("yaml");

const concaveman = require("concaveman");
const simplify = require("simplify-js");

const { smallestSurroundingRectangleByArea } = require("geojson-minimum-bounding-rectangle");

var IS_BROWSER = typeof process == 'undefined' || process.browser;
var cheerio, TFrecordsBuilder, FeatureType;
if (!IS_BROWSER) {
    var fs = require('fs');
    Handlebars = require('handlebars');
    var vocTemplate = Handlebars.compile(fs.readFileSync(__dirname + "/templates/voc.tmpl", "utf-8"));
    var labelmapTemplate = Handlebars.compile(fs.readFileSync(__dirname + "/templates/pbtxt.tmpl", "utf-8"));

    cheerio = require('cheerio');
    const tfrecords = require("@roboflow/tfrecords");

    TFRecordsBuilder = tfrecords.TFRecordsBuilder;
    FeatureType = tfrecords.FeatureType;
}

var xmin = function (box) {
    return Math.round(box.x - box.width / 2);
};

var xmax = function (box) {
    return Math.round(box.x + box.width / 2);
};

var ymin = function (box) {
    return Math.round(box.y - box.height / 2);
};

var ymax = function (box) {
    return Math.round(box.y + box.height / 2);
};

var automlLabel = function (label) {
    return label.replace(/\-/g, "_").replace(/[^a-zA-Z0-9_]/g, "").replace(/^([0-9_])/, "L$1") || "object";
};

function Annotation(ours, key, annotationGroup, datasetName) {
    if (!ours) ours = "";

    this.key = key || ours.key;
    this.extra = ours.extra || null;
    this.original = ours.original || "";
    this.converted = ours.converted || ours || "{}";
    this.annotationGroup = annotationGroup || "";
    this.datasetName = datasetName || "";
    if (typeof this.converted == "string") this.converted = JSON.parse(this.converted);

    if (this.converted.boxes) {
        _.each(this.converted.boxes, function (box) {
            // fix empty labels
            if (!box.label || !box.label.length) box.label = annotationGroup || "object";
        });
    }

    this.labels = function () {
        var labels = {};
        _.each(this.converted.boxes, function (box) {
            labels[box.label] = true;
        });
        return _.keys(labels);
    };

    this.to = function (format) { };

    this.toLabelBox = function () { };
    this.toRectLabel = function () { };
    this.toCSV = function () { };

    this.toCOCO = function (image_id, label_id, labelmap) {
        var out = {
            image: {
                "id": image_id,
                "license": 1,
                "file_name": (_.isArray(this.key) ? this.key[0] : this.key) + "",
                "height": this.converted.height,
                "width": this.converted.width,
                "date_captured": moment().format(),
            },
            annotations: []
        };
        if (this.extra) {
            // Only add extra prop to images if extra exists
            out.image.extra = this.extra;
        }

        _.each(this.converted.boxes, function (box) {
            var segments = [];
            if (box.points) {
                _.each(box.points, function (point) {
                    segments.push(point[0]);
                    segments.push(point[1]);
                });
                segments = [segments]; // COCO supports multi-polygons
            }

            var extra = null;
            if (box.attributes && box.attributes.length > 0) {
                extra = { 
                    ...extra, 
                    attributes: box.attributes 
                };
            }

            // Assumes all box.keypoints are valid (i.e. not deleted, or implicit from skeleton)
            // All keypoints.x and .y should be relative to image 0,0
            let keypoints = box?.keypoints?.sort((a, b) => a.id - b.id)?.reduce(function (accumulatedKeypoints, keypoint) {
                let visibility = 2;
                if (keypoint.deleted) visibility = 0;
                else if (keypoint.occluded) visibility = 1;
                return accumulatedKeypoints.concat([parseFloat(keypoint.x), parseFloat(keypoint.y), parseFloat(visibility)]);
            }, []);

            const convertedAnnotation = {
                "id": label_id++,
                "image_id": image_id,
                "category_id": labelmap[box.label].id,
                "bbox": [
                    xmin(box), // left
                    ymin(box), // top
                    box.width, // width
                    box.height // height
                ],
                "area": box.width * box.height,
                "segmentation": segments,
                "iscrowd": 0
            }

            // Only add extra to annotation if properties have been added
            if (extra) convertedAnnotation.extra = extra;

            if (keypoints?.length > 0) convertedAnnotation.keypoints = keypoints;

            out.annotations.push(convertedAnnotation);
        });

        return out;
    };

    this.toCreateML = function () {
        var out = {
            image: (_.isArray(this.key) ? this.key[0] : this.key) + "",
            annotations: []
        };

        _.each(this.converted.boxes, function (box) {
            out.annotations.push({
                label: box.label,
                coordinates: {
                    x: box.x,
                    y: box.y,
                    width: box.width,
                    height: box.height
                }
            });
        });

        if (!out.annotations.length) return null;

        return out;
    };

    this.toTensorflow = function () {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var width = this.converted.width;
        var height = this.converted.height;

        var out = [];
        _.each(this.converted.boxes, function (box) {
            out.push([
                key,
                width,
                height,
                box.label,
                xmin(box),
                ymin(box),
                xmax(box),
                ymax(box)
            ].join(','));
        });

        return out.join("\n");
    };

    this.toAutoML = function (split) {
        switch (split) {
            case 'train':
                split = "TRAIN";
                break;
            case 'valid':
                split = "VALIDATE";
                break;
            case 'test':
                split = "TEST";
                break;
            default: split = "UNASSIGNED";
        }

        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var width = this.converted.width;
        var height = this.converted.height;

        var out = [];
        if (!this.converted.boxes.length) {
            out.push([
                split,
                key,
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                "",
                ""
            ].join(','));
        }

        _.each(this.converted.boxes, function (box) {
            // x_relative_min,y_relative_min,x_relative_max,y_relative_min,x_relative_max,y_relative_max,x_relative_min,y_relative_max
            out.push([
                split,
                key,
                automlLabel(box.label),
                xmin(box) / width,
                ymin(box) / height,
                xmax(box) / width,
                ymin(box) / height,
                xmax(box) / width,
                ymax(box) / height,
                xmin(box) / width,
                ymax(box) / height
            ].join(','));
        });

        return out.join("\n");
    };

    this.toSagemaker = function (labelmap) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var width = this.converted.width;
        var height = this.converted.height;

        var classMap = {};
        var found = {};
        var id = 0;
        _.each(this.converted.boxes, function (box) {
            if (typeof found[box.label] == "undefined") {
                found[box.label] = id;
                classMap[id] = box.label;
                id++;
            }
        });
        // _.each(labelmap, function(label) {
        //     // zero index
        //     classMap[label.id - 1] = label.name;
        // });

        var ret = {
            "source-ref": this.s3source || "s3://",
            "roboflow": {
                "annotations": [],
                "image_size": [{
                    "width": width,
                    "depth": 3,
                    "height": height
                }]
            },
            "roboflow-metadata": {
                "job-name": "labeling-job/roboflow",
                "class-map": classMap,
                "human-annotated": "yes",
                "objects": [],
                "creation-date": moment().utc().format("YYYY-MM-DDTHH:mm:ss.SSSSS"),
                "type": "groundtruth/object-detection"
            }
        };

        _.each(this.converted.boxes, function (box) {
            ret.roboflow.annotations.push({
                // class_id: "" + (labelmap[box.label].id-1),
                class_id: found[box.label],
                width: Math.round(box.width),
                top: Math.round(ymin(box)),
                height: Math.round(box.height),
                left: Math.round(xmin(box))
            });

            ret["roboflow-metadata"].objects.push({
                "confidence": 0.09
            });
        });

        return JSON.stringify(ret);
    };

    this.toVOC = function () {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var xmlName = key.split(".").slice(0, -1).join(".") + ".xml";

        var data = _.clone(this.converted);
        data.filename = key;
        data.boxes = _.map(data.boxes, function (box) {
            // add 1 because VOC XML's top-left pixel is 1,1 rather than 0,0
            box.xmin = xmin(box) + 1;
            box.ymin = ymin(box) + 1;
            box.xmax = xmax(box) + 1;
            box.ymax = ymax(box) + 1;

            if (box.points) {
                box.points = _.map(box.points, function (point, i) {
                    return {
                        x: point[0],
                        y: point[1],
                        i: (i + 1)
                    };
                });
            }

            return box;
        });
        const metadata = this.extra;
        if (metadata) {
            data.metadata = metadata;
        }

        return {
            name: xmlName,
            contents: vocTemplate(data)
        };
    };

    this.toBenchmarker = function () {
        var out = [];

        var filename = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        _.each(this.converted.boxes, function (box) {
            out.push({
                "filename": filename,
                "label": box.label,
                "left": xmin(box),
                "top": ymin(box),
                "bottom": ymax(box),
                "right": xmax(box)
            });
        });

        return out;
    }

    this.toAzure = function (labels) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";

        var ret = [];

        var width = this.converted.width;
        var height = this.converted.height;
        _.each(this.converted.boxes, function (box) {
            ret.push({
                tagId: labels[box.label],
                left: xmin(box) / width,
                top: ymin(box) / height,
                width: box.width / width,
                height: box.height / height
            });
        });
        return ret;
    };

    this.toYoloDarknet = function (labelmap) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var txtName = key.split(".").slice(0, -1).join(".") + ".txt";

        var rows = [];

        var width = this.converted.width;
        var height = this.converted.height;
        _.each(this.converted.boxes, function (box) {
            rows.push([
                labelmap[box.label].id - 1,
                box.x / width,
                box.y / height,
                box.width / width,
                box.height / height
            ].join(" "));
        });

        return {
            name: txtName,
            contents: rows.join("\n")
        };
    };

    this.getYolo5OBB = function (box, points, width, height) {
        return [
            points[0][0] * width, // convert back to pixel coordinates
            points[0][1] * height,
            points[1][0] * width,
            points[1][1] * height,
            points[2][0] * width,
            points[2][1] * height,
            points[3][0] * width,
            points[3][1] * height,
            (box.label || "object").trim().replace(/\s/g, "-"), // replace whitespace because space-separated TXT
            0
        ].join(" ");
    }

    this.getYolo8OBB = function (box, points, width, height, labelmap) {
        let class_index = labelmap[box.label];
        return [
            class_index || 0, // class_index
            points[0][0], // convert back to pixel coordinates
            points[0][1],
            points[1][0],
            points[1][1],
            points[2][0],
            points[2][1],
            points[3][0],
            points[3][1]
        ].join(" ");
    }

    this.toYoloOBB = function (labelmap, convertToObb) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var txtName = key.split(".").slice(0, -1).join(".") + ".txt";

        var rows = [];

        var width = this.converted.width || 10000;
        var height = this.converted.height || 10000;
        _.each(this.converted.boxes, function (box) {
            if (!box.points || !box.points.length) {
                if (!box.width || !box.height) return;

                // convert bbox to polygon (if necessary)
                box.points = [
                    [xmin(box), ymin(box)],
                    [xmax(box), ymin(box)],
                    [xmax(box), ymax(box)],
                    [xmin(box), ymax(box)]
                ];
            }

            var geoJSON = {
                "type": "FeatureCollection",
                "features": [
                    {
                        "type": "Feature",
                        "geometry": {
                            "type": "Polygon",
                            "coordinates": [
                                _.map(box.points, function (point) {
                                    // turf requires points to be normalized
                                    return [point[0] / width, point[1] / height];
                                })
                            ]
                        },
                        "id": "bbox"
                    }
                ]
            };

            // convert polygon to rotated box
            var rect;
            try {
                rect = smallestSurroundingRectangleByArea(geoJSON);
            } catch (e) {
                return;
            }

            var points = rect.geometry.coordinates[0];

            rows.push(convertToObb(box, points, width, height, labelmap));
        });

        return {
            name: txtName,
            contents: rows.join("\n")
        };
    };

    this.toYoloDarknet5 = function (labelmap, version) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var txtName = key.split(".").slice(0, -1).join(".") + ".txt";

        const skeleton = skeletonWithGreatestVertexCount(version?.skeletons, labelmap, version?.preprocessing?.remap?.labels);

        var rows = [];

        var width = this.converted.width;
        var height = this.converted.height;
        _.each(this.converted.boxes, function (box) {
            // Keypoint Detection projects store keypoints in place of segmentation points
            if (box.points && box.points.length >= 3 && version?.type !== "keypoint-detection") {
                // export polygon segmentation (requires 3 points as of https://github.com/ultralytics/yolov5/pull/6938)
                var row = [labelmap[box.label].id - 1];
                _.each(box.points, function (point) {
                    row.push(point[0] / width);
                    row.push(point[1] / height);
                });
                rows.push(row.join(" "));
            } else {
                // use bbox format
                const row = [
                    labelmap[box.label].id - 1,
                    box.x / width,
                    box.y / height,
                    box.width / width,
                    box.height / height
                ];
                if (skeleton?.vertices?.length > 0) {
                    const sortedVertices = skeleton.vertices.sort((a, b) => a.id - b.id);
                    // Assumes all box.keypoints are valid (i.e. not deleted, or implicit from skeleton)
                    // All keypoints.x and .y should be relative to image 0,0
                    _.each(sortedVertices, function (vertex) {
                        const keypoint = box.keypoints.find(keypoint => keypoint.id === vertex.id);
                        if (keypoint){
                            // Update to use normalized coordinates
                            row.push(keypoint.x / width);
                            row.push(keypoint.y / height);
                            if (keypoint.deleted) row.push(0);
                            else if (keypoint.occluded) row.push(1);
                            else row.push(2);
                        } else {
                            // add 0, 0, 0 dummy points for keypoints that don't exist
                            // needed because YOLO is single-class and expects a fixed number of keypoints
                            row.push(0);
                            row.push(0);
                            row.push(0);
                        }
                    });
                }
                rows.push(row.join(" "));
            }
        });

        return {
            name: txtName,
            contents: rows.join("\n")
        };
    };

    this.toYoloKeras = function (labelmap) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var parts = [key];

        var width = this.converted.width;
        var height = this.converted.height;
        _.each(this.converted.boxes, function (box) {
            parts.push([
                xmin(box),
                ymin(box),
                xmax(box),
                ymax(box),
                labelmap[box.label].id - 1
            ].join(","));
        });

        return parts.join(" ");
    };

    this.toMulticlassClassification = function (headers) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";
        var parts = [key];

        var classes = {};
        _.each(this.converted.boxes, function (box) {
            classes[box.label] = true;
        });

        _.each(headers, function (header) {
            parts.push(classes[header] ? 1 : 0);
        });

        return parts.join(", ");
    };

    this.toClip = function () {
        var classes = {};
        var empty = true;
        _.each(this.converted.boxes, function (box) {
            empty = false;

            if (!classes[box.label]) classes[box.label] = 0;
            classes[box.label]++;
        });

        var folderName, description;
        if (empty) {
            folderName = "empty";
            description = "An example picture from the " + this.datasetName + " dataset depicting no " + pluralize(this.annotationGroup, 0);
        } else {
            folderName = _.keys(classes).sort();
            description = "An example picture from the " + this.datasetName + " dataset depicting ";

            var descriptiveClasses = [];
            _.each(folderName, function (cls) {
                var num = classes[cls];

                var parts = cls.split("-");
                var end = parts.pop();
                end = pluralize(end, num);
                parts.push(end);
                cls = parts.join(" ");

                descriptiveClasses.push(
                    num == 1 ? "a " + cls : cls
                );
            });

            folderName = _.map(folderName, function (cls) {
                if (classes[cls] == 1) {
                    return cls;
                } else {
                    return cls + "_multiple";
                }
            });

            if (descriptiveClasses.length > 1) descriptiveClasses[descriptiveClasses.length - 1] = "and " + descriptiveClasses[descriptiveClasses.length - 1];
            description += descriptiveClasses.join(", ");

            folderName = folderName.join(" ");
        }

        return [
            folderName, description
        ];
    };

    this.toRetinanet = function () {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";

        var rows = [];

        var width = this.converted.width;
        var height = this.converted.height;
        _.each(this.converted.boxes, function (box) {
            rows.push([
                key,
                xmin(box),
                ymin(box),
                xmax(box),
                ymax(box),
                box.label
            ].join(","));
        });

        return rows.join("\n");
    };

    this.toTFRecord = function (imageBuffer, labelmap) {
        var key = (_.isArray(this.key) ? this.key[0] : this.key) + "";

        var width = this.converted.width;
        var height = this.converted.height;

        var xmins = [];
        var ymins = [];
        var xmaxes = [];
        var ymaxes = [];
        var tags = [];
        var labels = [];

        _.each(this.converted.boxes, function (box) {
            tags.push(box.label);
            labels.push(labelmap[box.label].id);
            xmins.push(xmin(box) / width);
            ymins.push(ymin(box) / height);
            xmaxes.push(xmax(box) / width);
            ymaxes.push(ymax(box) / height);
        });

        // Generate TFRecord
        const builder = new TFRecordsBuilder();

        builder.addFeature("image/width", FeatureType.Int64, width);
        builder.addFeature("image/height", FeatureType.Int64, height);
        builder.addFeature("image/filename", FeatureType.String, key);
        builder.addFeature("image/encoded", FeatureType.Binary, imageBuffer);
        builder.addFeature("image/format", FeatureType.String, "jpeg");
        builder.addArrayFeature("image/object/bbox/xmin", FeatureType.Float, xmins);
        builder.addArrayFeature("image/object/bbox/ymin", FeatureType.Float, ymins);
        builder.addArrayFeature("image/object/bbox/xmax", FeatureType.Float, xmaxes);
        builder.addArrayFeature("image/object/bbox/ymax", FeatureType.Float, ymaxes);
        builder.addArrayFeature("image/object/class/text", FeatureType.String, tags);
        builder.addArrayFeature("image/object/class/label", FeatureType.Int64, labels);

        // Build single TFRecord
        return builder.build();
    };
}

var combineToCOCOSegmentation = function (annotations, labelmap, dataset, version) {
    var ret = combineToCOCO(annotations, labelmap, dataset, version);

    // convert any bounding boxes to 4-vertex segmentations
    var parsed = JSON.parse(ret[0].contents);

    parsed.annotations = _.map(parsed.annotations, function (a) {
        if (!a.segmentation || !_.isArray(a.segmentation) || !a.segmentation.length) {
            var left = a.bbox[0];
            var top = a.bbox[1];
            var right = a.bbox[0] + a.bbox[2];
            var bottom = a.bbox[1] + a.bbox[3];

            a.segmentation = [
                [
                    left,
                    top,
                    right,
                    top,
                    right,
                    bottom,
                    left,
                    bottom
                ]
            ];
        }

        return a;
    });

    ret[0].contents = JSON.stringify(parsed);

    return ret;
}

var combineToCOCO = function (annotations, labelmap, dataset, version) {
    var ret = {
        name: '_annotations.coco.json'
    };

    var url = "https://app.roboflow.com/datasets/" + dataset.url + "/" + version.id;
    if (dataset.public) url = "https://public.roboflow.com/object-detection/" + dataset.publicUrl;

    var license = {
        "id": 1,
        "url": dataset.licenseLink || "",
        "name": dataset.license || "Unknown"
    };

    var output = {
        "info": {
            "year": moment().format("YYYY"),
            "version": version.id,
            "description": "Exported from roboflow.com",
            "contributor": dataset.authorName || "",
            "url": url,
            "date_created": moment().format()
        },
        "licenses": [license],
        "categories": [{
            "id": 0,
            "name": dataset.annotation,
            "supercategory": "none"
        }],
        "images": [],
        "annotations": []
    };

    var map_id = 1;
    const skeletons = remappedSkeletons(version?.skeletons, version?.preprocessing?.remap?.labels);
    _.each(labelmap, function (l) {
        const keypoints = skeletons?.[l.name]?.vertices?.map(vertex => vertex?.name);
        const skeleton = skeletons?.[l.name]?.edges?.map(edge => {
            const from = skeletons?.[l.name]?.vertices?.findIndex(vertex => vertex?.id === edge?.from) + 1;
            const to = skeletons?.[l.name]?.vertices?.findIndex(vertex => vertex?.id === edge?.to) + 1;
            return [from, to];
        });

        const category = {
            "id": map_id++,
            "name": l.name,
            "supercategory": dataset.annotation
        };

        if (keypoints) category.keypoints = keypoints;
        if (skeleton) category.skeleton = skeleton;

        output.categories.push(category);
    });

    var image_id = 0;
    var label_id = 0;

    _.each(annotations, function (a) {
        a = a.toCOCO(image_id, label_id, labelmap);
        output.images.push(a.image);
        _.each(a.annotations, function (a) {
            output.annotations.push(a);
        });

        image_id = image_id + 1;
        label_id = label_id + a.annotations.length;
    });

    ret.contents = JSON.stringify(output, function (key, val) {
        return val && val.toFixed ? Number(val.toFixed(3)) : val;
    });
    return [ret];
};

var combineToCOCOMMDetection = function (annotations, labelmap, dataset, version) {
    var ret = {
        name: '_annotations.coco.json'
    };

    var url = "https://app.roboflow.com/datasets/" + dataset.url + "/" + version.id;
    if (dataset.public) url = "https://public.roboflow.com/object-detection/" + dataset.publicUrl;

    var license = {
        "id": 1,
        "url": dataset.licenseLink || "",
        "name": dataset.license || "Unknown"
    };

    var output = {
        "info": {
            "year": moment().format("YYYY"),
            "version": version.id,
            "description": "Exported from roboflow.com",
            "contributor": dataset.authorName || "",
            "url": url,
            "date_created": moment().format()
        },
        "licenses": [license],
        "categories": [],
        "images": [],
        "annotations": []
    };

    var map_id = 1;
    _.each(labelmap, function (l) {
        output.categories.push({
            "id": map_id++,
            "name": l.name
        });
    });

    var image_id = 0;
    var label_id = 0;

    _.each(annotations, function (a) {
        a = a.toCOCO(image_id, label_id, labelmap);
        output.images.push(a.image);
        _.each(a.annotations, function (a) {
            output.annotations.push(a);
        });

        image_id = image_id + 1;
        label_id = label_id + a.annotations.length;
    });

    ret.contents = JSON.stringify(output, function (key, val) {
        return val && val.toFixed ? Number(val.toFixed(3)) : val;
    });
    return [ret];
};

var combineToBenchmarker = function (annotations, labelmap, dataset, version) {
    var ret = {
        name: '_groundtruth.json'
    };

    var output = [];

    _.each(annotations, function (a) {
        _.each(a.toBenchmarker(), function (a) {
            output.push(a);
        });
    });

    ret.contents = JSON.stringify(output);
    return [ret];
};

var combineToCreateML = function (annotations) {
    var ret = {
        name: '_annotations.createml.json'
    };

    var output = [];
    _.each(annotations, function (a) {
        a = a.toCreateML();
        if (a) output.push(a); // ignore null annotations
    });

    ret.contents = JSON.stringify(output);
    return [ret];
};

var combineToTensorflow = function (annotations) {
    var ret = {
        name: '_annotations.csv',
        contents: ["filename,width,height,class,xmin,ymin,xmax,ymax"]
    };

    _.each(annotations, function (a) {
        ret.contents.push(a.toTensorflow());
    });

    ret.contents = ret.contents.join("\n");
    return [ret];
};

var combineToAutoML = function (annotations) {
    var ret = {
        name: 'annotations.csv',
        contents: []
    };

    _.each(annotations, function (a) {
        ret.contents.push(a.toAutoML());
    });

    ret.contents = ret.contents.join("\n");
    return [ret];
};

var combineToSagemaker = function (annotations, labelmap) {
    var ret = {
        name: 'roboflow.manifest',
        contents: []
    };

    _.each(annotations, function (a) {
        ret.contents.push(a.toSagemaker(labelmap));
    });

    ret.contents = ret.contents.join("\n");
    return [ret];
};

var combineToVoc = function (annotations) {
    var ret = [];

    _.each(annotations, function (a) {
        if (!a.converted || typeof a.converted.width == "undefined" || typeof a.converted.height == "undefined") return; // unannotated image
        ret.push(a.toVOC());
    });

    return ret;
};

var combineToYoloDarknet = function (annotations, labelmap) {
    var files = _.map(annotations, function (a) {
        return a.toYoloDarknet(labelmap);
    });

    files.push({
        name: "_darknet.labels",
        contents: _.keys(labelmap).sort().join("\n")
    });

    return files;
};

var filterDeletedPointsFromSkeleton = function (skeleton) {
    // Deep copy skeleton to avoid mutating original
    const skeletonCopy = _.cloneDeep(skeleton);
    if (skeletonCopy?.vertices) {
        const vertices = skeletonCopy.vertices.filter(vertex => !vertex?.deleted);
        skeletonCopy.vertices = vertices.sort((a, b) => a.id - b.id);
    }
    if (skeletonCopy?.edges) {
        skeletonCopy.edges = skeletonCopy.edges.filter(edge => {
            const from = skeletonCopy?.vertices?.find((v) => v?.id === edge?.from);
            const to = skeletonCopy?.vertices?.find((v) => v?.id === edge?.to);
            return !from?.deleted && !to?.deleted;
        });
    }
    if (skeletonCopy?.symmetries) {
        skeletonCopy.symmetries = skeletonCopy.symmetries.filter(symmetry => {
            for (const point of symmetry?.points) {
                const pointV = skeletonCopy?.vertices?.find((v) => v?.id === point);
                if (pointV?.deleted) {
                    return false;
                }
            }
            return true;
        });
    }
    return skeletonCopy;
}

var remappedSkeletons = function (skeletons, remapLabels) {
    const includedSkeletons = _.omitBy(skeletons, (skeleton, label) => remapLabels?.[label]?.omit);
    const remappedSkeletons = _.mapKeys(includedSkeletons, (skeleton, label) => remapLabels?.[label]?.override ? remapLabels?.[label]?.override : label);
    return _.mapValues(remappedSkeletons, filterDeletedPointsFromSkeleton);
}

var skeletonWithGreatestVertexCount = function (skeletons, labelmap, remapLabels) {
    if (skeletons) {
        if (remapLabels) {
            skeletons = remappedSkeletons(skeletons, remapLabels);
        }
        const classes = _.keys(labelmap);
        // Finds the skeleton class with the greatest number of vertices for single class keypoint detection
        const skeletonsClassesWithAnnotations = _.filter(_.keys(skeletons), className => classes.includes(className));
        
        const skeletonClassWithGreatestVertexCount = _.maxBy(skeletonsClassesWithAnnotations, function (className) {
            return skeletons[className]?.vertices?.length || 0;
        });
        return skeletons[skeletonClassWithGreatestVertexCount];
    }
}

var combineToYoloDarknet5 = function (annotations, labelmap, dataset, version, workspaceUrl) {
    var files = _.map(annotations, function (a) {
        var annotation = a.toYoloDarknet5(labelmap, version);
        annotation.name = "labels/" + annotation.name;
        return annotation;
    });

    var url;
    if(dataset.public) {
        url = `https://universe.roboflow.com/${workspaceUrl || "project"}/${dataset.url}/dataset/${version.id}`;
    } else {
        url = `https://app.roboflow.com/${workspaceUrl || "project"}/${dataset.url}/${version.id}`;
    }
    let sorted_keys = _.keys(labelmap).sort();
    let keypointOptions = [];
    const skeletonMaxVertices = skeletonWithGreatestVertexCount(version?.skeletons, labelmap, version?.preprocessing?.remap?.labels);
    if (skeletonMaxVertices && skeletonMaxVertices?.vertices?.length > 0) {
        // Finds the horizontal symmetries for the skeleton class with the greatest number of vertices
        const horizontalSymmetries = skeletonMaxVertices.symmetries?.filter(symmetry => symmetry.direction === "horizontal");
        let keypointIndexArray = Array.from({length: skeletonMaxVertices.vertices.length}, (_, i) => i);
        for (const i of keypointIndexArray) {
            const indexId = skeletonMaxVertices.vertices[i].id;
            const indexSymmetry = horizontalSymmetries?.find(symmetry => symmetry.points.includes(indexId));
            if (indexSymmetry) {
                let symmetricalVertexId = indexSymmetry.points[0] === indexId ? indexSymmetry.points[1] : indexSymmetry.points[0];
                const symmetricalIndex = skeletonMaxVertices.vertices.findIndex(vertex => vertex.id === symmetricalVertexId);
                keypointIndexArray[i] = symmetricalIndex;
                keypointIndexArray[symmetricalIndex] = i;
            }
        }
        const flipIdx = keypointIndexArray.join(", ");
        keypointOptions.push(`kpt_shape: [${skeletonMaxVertices.vertices.length}, 3]`);
        keypointOptions.push(`flip_idx: [${flipIdx}]`);
        keypointOptions.push("");
    }
    files.push({
        name: "data.yaml",
        contents: [
            "train: ../train/images",
            "val: ../valid/images",
            "test: ../test/images",
            "",
            ...keypointOptions,
            "nc: " + _.keys(labelmap).length,
            "names: [" + sorted_keys.map(function (l) {
                var escapedLabel = l.replace(new RegExp("'", "g"), "''");
                return "'" + escapedLabel + "'";
            }).join(", ") + "]",
            "",
            "roboflow:",
            `  workspace: ${workspaceUrl || "project"}`,
            `  project: ${dataset.url}`,
            `  version: ${version.id}`,
            `  license: ${dataset.license || "Private"}`,
            `  url: ${url}`
        ].join("\n")
    });

    return files;
};

var combineToMTYolo6 = function (annotations, labelmap) {
    var files = _.map(annotations, function (a) {
        var annotation = a.toYoloDarknet5(labelmap);
        return annotation;
    });
    let sorted_keys = _.keys(labelmap).sort();
    files.push({
        name: "data.yaml",
        contents: [
            "train: ./images/train",
            "val: ./images/valid",
            "test: ./images/test",
            "",
            "nc: " + _.keys(labelmap).length,
            "names: [" + sorted_keys.map(function (l) {
                return "'" + l + "'";
            }).join(", ") + "]"
        ].join("\n")
    });

    return files;
};

var combineToYolo5OBB = function (annotations, labelmap) {
    var files = _.map(annotations, function (a) {
        var annotation = a.toYoloOBB(labelmap, a.getYolo5OBB);
        annotation.name = "labelTxt/" + annotation.name;
        return annotation;
    });
    let sorted_keys = _.keys(labelmap).sort();
    files.push({
        name: "data.yaml",
        contents: [
            "path: ../datasets/roboflow",
            "",
            "train: train/images",
            "val: valid/images",
            "test: test/images",
            "",
            "nc: " + _.keys(labelmap).length,
            "names: [" + sorted_keys.map(function (l) {
                return "'" + l + "'";
            }).join(", ") + "]"
        ].join("\n")
    });

    return files;
};

var combineToYolo8OBB = function (annotations, labelmap) {
    let sorted_keys = _.keys(labelmap).sort();
    let sorted_labelmap = sorted_keys.reduce((obj, name, index) => {
        obj[name] = index;
        return obj;
    }, {});

    var files = _.map(annotations, function (a) {
        var annotation = a.toYoloOBB(sorted_labelmap, a.getYolo8OBB);
        annotation.name = "labels/" + annotation.name;
        return annotation;
    });

    files.push({
        name: "data.yaml",
        contents: [
            "path: ../datasets/roboflow",
            "",
            "train: train/images",
            "val: valid/images",
            "test: test/images",
            "",
            "names: \n" + sorted_keys.map(function (key, index) {
                return `  ${index}: ${key}`
            }).join('\n')
        ].join("\n")
    });

    return files;
};

var combineToYoloKeras = function (annotations, labelmap) {
    var lines = _.map(annotations, function (a) {
        return a.toYoloKeras(labelmap);
    });

    return [{
        name: "_annotations.txt",
        contents: lines.join("\n")
    }, {
        name: "_classes.txt",
        contents: _.keys(labelmap).sort().join("\n")
    }];
};

var combineToClip = function (annotations, labelmap) {
    var classes = {};
    _.each(annotations, function (a) {
        var [folder, description] = a.toClip();
        classes[folder] = description;
    });

    var lines = [];
    _.each(_.keys(classes).sort(), function (cls) {
        lines.push(classes[cls]);
    });

    return [{
        name: "_tokenization.txt",
        contents: lines.join("\n")
    }];
};

var combineToMulticlassClassification = function (annotations, labelmap) {
    var headers = _.keys(labelmap).sort();

    var lines = _.map(annotations, function (a) {
        return a.toMulticlassClassification(headers);
    });

    headers.unshift("filename");
    lines.unshift(headers.join(", "));

    return [{
        name: "_classes.csv",
        contents: lines.join("\n")
    }];
};

var combineToPngMaskSemantic = function (annotations, labelmap) {
    var classes = _.keys(labelmap).sort();
    classes.unshift("background")
    var lines = _.map(classes, function (c, idx) {
        return idx + ', ' + c;
    });

    var headers = ['Pixel Value', 'Class']
    lines.unshift(headers.join(", "));

    return [{
        name: "_classes.csv",
        contents: lines.join("\n")
    }];
};

var combineToRetinanet = function (annotations) {
    var lines = _.map(annotations, function (a) {
        return a.toRetinanet();
    });

    return [{
        name: "_annotations.csv",
        contents: lines.join("\n")
    }];
};

Annotation.combine = function (annotations, format, labelmap, dataset, version, workspaceUrl) {
    switch (format) {
        case 'coco': return combineToCOCO(annotations, labelmap, dataset, version);
        case 'coco-segmentation': return combineToCOCOSegmentation(annotations, labelmap, dataset, version);
        case 'coco-mmdetection': return combineToCOCOMMDetection(annotations, labelmap, dataset, version);
        case 'benchmarker': return combineToBenchmarker(annotations, labelmap, dataset, version);
        case 'createml': return combineToCreateML(annotations);
        case 'tensorflow': return combineToTensorflow(annotations);
        case 'voc': return combineToVoc(annotations);
        case 'darknet': return combineToYoloDarknet(annotations, labelmap);
        case 'yolov4scaled': // same as yolov5pytorch
        case 'yolov7pytorch': // same as yolov5pytorch
        case 'yolov8': // same as yolov5pytorch
        case 'yolov9': // same as yolov5pytorch
        case 'yolov5pytorch': return combineToYoloDarknet5(annotations, labelmap, dataset, version, workspaceUrl);
        case 'yolov8-obb': return combineToYolo8OBB(annotations, labelmap);
        case 'yolov5-obb': return combineToYolo5OBB(annotations, labelmap);
        case 'mt-yolov6': return combineToMTYolo6(annotations, labelmap);
        case 'yolov4pytorch': // same as yolokeras
        case 'yolokeras': return combineToYoloKeras(annotations, labelmap);
        case 'retinanet': return combineToRetinanet(annotations);
        case 'automl': return combineToAutoML(annotations);
        case 'rekognition':
        case 'sagemaker': return combineToSagemaker(annotations, labelmap);
        case 'clip': return combineToClip(annotations, labelmap, dataset);
        case 'multiclass': return combineToMulticlassClassification(annotations, labelmap);
        case 'png-mask-semantic': return combineToPngMaskSemantic(annotations, labelmap);
        default:
            console.log('unsupported annotation format', format);
            return [];
    }
};

Annotation.humanReadable = function (format) {
    switch (format) {
        case "coco": return "COCO";
        case "coco-segmentation": return "COCO Segmentation";
        case "coco-mmdetection": return "COCO for MMDetection";
        case "benchmarker": return "Roboflow Server Benchmark Tool";
        case "createml": return "CreateML";
        case "labelbox": return "LabelBox";
        case "sagemaker": return "SageMaker";
        case "scale": return "Scale.com";
        case "turi": return "Turi Create";
        case "voc": return "Pascal VOC";
        case "darknet": return "YOLO v3 Darknet";
        case "yolov4scaled": return "Scaled-YOLOv4";
        case "yolov5pytorch": return "YOLO v5 PyTorch";
        case "yolov7pytorch": return "YOLO v7 PyTorch";
        case "yolov8": return "YOLOv8";
        case "yolov9": return "YOLOv9";
        case "yolov8-obb": return "YOLOv8 Oriented Object Detection";
        case "yolov5-obb": return "YOLOv5 Oriented Object Detection";
        case "mt-yolov6": return "MT-YOLOv6";
        case "yolov4pytorch": return "YOLO v4 PyTorch";
        case "yolokeras": return "YOLO v3 (Keras)";
        case "kitti": return "KITTI";
        case "automl": return "Google Cloud AutoML";
        case "tensorflow": return "Tensorflow Object Detection";
        case "tfrecord": return "Tensorflow TFRecord (raccoon)";
        case "multiclass": return "Multi-Class Classification";
        case "png-mask-semantic": return "PNG Masks For Semantic Segmentation"
        default: return format;
    }
};

Annotation.renderLabelMap = function (labelmap) {
    return labelmapTemplate({
        labels: labelmap
    });
};

Annotation.parse = function (text, filename, extension, labelmap) {
    var info = Annotation.identify(text, extension);

    var parse = Annotation["parse" + info.type] || function () {
        return [{
            info: info
        }];
    };

    if (info.format == "json" && Annotation["parse" + info.type] && info.type != "LabelBoxVideo") {
        text = JSON.parse(text);
    } else if (typeof text == "string") {
        // prevent windows-style newlines from messing up our parsers (eliminate \r to replace \r\n with \n)
        text = text.replace(/\r/g, "");
    }

    var parsed = parse(text, extension, filename.replace("." + extension, ""), labelmap);
    if (!parsed.length) parsed = [parsed];

    parsed = _.map(parsed, function (a) {
        if (!a.annotation && !a.info && !a.error && !a.warning) {
            a = {
                annotation: a
            };
        }

        if (a && a.annotation && a.annotation.converted && a.annotation.converted.boxes) {
            _.each(a.annotation.converted.boxes, function (box) {
                if (box.label) {
                    box.label = ("" + box.label)
                        .trim()                             // no leading or trailing whitespace
                        .replace(/\s+/g, " ")               // normalize whitespace
                        .replace(/[\/\.\[\]\#\~\*]/g, "-");  // invalid firebase keys
                }

                if (labelmap && labelmap[parseInt(box.label)]) box.label = labelmap[parseInt(box.label)];

                if (!box.label || !box.label.length) box.label = "object";
            });
        }

        if (!a.info) {
            a.info = info;
        }

        if (a.error) a.error.annotationFilename = filename;
        if (a.warning) a.warning.annotationFilename = filename;

        return a;
    });

    return parsed;
};

Annotation.identify = require(__dirname + "/identify.js");

Annotation.parseLabelMap = function (text, extension) {
    var labels = [];

    if (!text || !text.length) return null;

    if (extension == "pbtxt") {
        var parts = text.split("item ");
        _.each(parts, function (part) {
            if (!part) return null;
            part = part.replace(/({|,)(\s*)([^\s^"]+):/mg, '$1$2"$3":'); // make valid JSON by adding quotes around keys
            // console.log(part);
            part = JSON.parse(part);
            labels[part.id] = labels[part.display_name] || part.name || "";
        });

        // if(!labels[0]) labels.shift();
    } else if (extension == "json" &&
        text.indexOf("attribute_groups") >= 0 &&
        text.indexOf("color") >= 0 &&
        text.indexOf("id") >= 0 &&
        text.indexOf("name") >= 0
    ) {
        // SuperAnnotate classes.json
        var parsed = JSON.parse(text);
        _.each(parsed, function (label) {
            labels[label.id] = label.name;
        });
    } else if (
        ["yaml", "yml"].includes(extension)
    ) {
        var parsedYaml = yaml.parse(text);
        labels = _.map(parsedYaml.names, function(name) {
            return name.replace(/'/g, '"')
        });
    } else {
        // try to filter out eg CSV files which are not labelmaps
        var specialChars = _.map(".,".split(""), function (c) { return "\\" + c; });
        var specialCharsRegEx = new RegExp(specialChars.join("|"))
        labels = text.split("\n").map(s => s.trim()).filter(s => !!s);
        var numLinesWithSpecialChars = _.filter(labels, function (l) {
            return l.match(specialCharsRegEx);
        }).length;
        // if all lines have special chars, it's probably not a labelmap
        if(numLinesWithSpecialChars == labels.length) return null;
    }
    return labels;
};

Annotation.parseKeypointSkeletonsCOCO = function (json) {
    var skeletons = {};
    var annotations = this.parseCOCO(json);
    _.each(json.categories, function (category) {
        if (category?.keypoints) {
            let categoryKeypoints = _.map(annotations, function (annotation) {
                return _.filter(annotation.converted.boxes, function (box) {
                    // filter out boxes that don't match the category
                    return box.label === category.name;
                });
            })
            .flat()
            .map((box) => {
                // normalize keypoints to be relative to the bounding box
                return box.keypoints.map((keypoint) => {
                    const boxLeft = box.x - box.width / 2;
                    const boxTop = box.y - box.height / 2;
                    const keypointRelativeX = keypoint.x - boxLeft;
                    const keypointRelativeY = keypoint.y - boxTop;

                    let normalizedKeypointX;
                    if (keypointRelativeX < 0) normalizedKeypointX = 0;
                    else if (keypointRelativeX > box.width) normalizedKeypointX = 1;
                    else normalizedKeypointX = keypointRelativeX / box.width;
                    let normalizedKeypointY;
                    if (keypointRelativeY < 0) normalizedKeypointY = 0;
                    else if (keypointRelativeY > box.height) normalizedKeypointY = 1;
                    else normalizedKeypointY = keypointRelativeY / box.height;

                    return {
                        ...keypoint,
                        x: normalizedKeypointX,
                        y: normalizedKeypointY
                    }
                }).sort((a, b) => a.id - b.id);
            })
            .filter((keypoints) => keypoints.length > 0)
            .reduce((acc, keypoints) => {
                // group keypoints by id
                keypoints.forEach((keypoint, i) => {
                    if (!acc[i]) acc[i] = [];
                    if (!keypoint.deleted) {
                        acc[i].push(keypoint);
                    }
                });
                return acc;
            }, [])
            .map((vertices) => {
                // average the x and y coordinates of the grouped keypoints
                return {
                    x: _.round(_.meanBy(vertices, (vertex) => vertex.x), 4),
                    y: _.round(_.meanBy(vertices, (vertex) => vertex.y), 4),
                };
            });

            skeletons[category.name] = {
                vertices: category?.keypoints?.map((name, i) => {
                    return {
                        name,
                        id: i,
                        x: categoryKeypoints[i]?.x || 0.5,
                        y: categoryKeypoints[i]?.y || 0.5,
                    };
                }) || [],
                edges: category?.skeleton?.map((edge, i) => ({
                    from: edge[0] - 1,
                    to: edge[1] - 1
                })) || [],
                symmetries: []
            };
        }
    });
    
    return skeletons;
}

Annotation.parseKeypointSkeletons = function (text, extension) {
    var info = Annotation.identify(text, extension);

    switch (info.type) {
        case "COCO":
            return Annotation.parseKeypointSkeletonsCOCO(JSON.parse(text));
        default:
            return null;
    }
}

Annotation.parseLabelBox = function (json, extension) {
    if (extension == "json") {
        var annotations = [];
        _.each(json, function (row) {
            annotations.push({
                labelBoxUrl: row['Labeled Data'],
                annotation: Annotation.parseLabelBoxJson(row)
            });
        });
        return annotations;
    } else {
        return {
            error: {
                icon: "error",
                type: "error",
                code: "warning:unsupported"
                // title: "LabelBox CSV Unsupported",
                // description: "Currently, we only support importing LabelBox annotations as JSON. Please re-export your annotations as JSON and try again."
            }
        };
    }
};

Annotation.parseLabelBoxJson = function (labelbox) {
    var original = {
        source: 'labelbox',
        format: 'json',
        annotation: JSON.stringify(labelbox)
    };

    var converted = {
        key: labelbox["External ID"] && labelbox["External ID"].split("/").pop(),
        boxes: []
    };

    // parse if points format
    _.each(labelbox.Label, function (geometries, label) {
        _.each(geometries, function (geometryContainer) {
            if (!geometryContainer.geometry || geometryContainer.geometry.length == 0) return;
            var geometry = geometryContainer.geometry;

            var minX = Infinity;
            var maxX = -Infinity;
            var minY = Infinity;
            var maxY = -Infinity;

            var points = [];
            _.each(geometry, function (point) {
                if (point.x < minX) minX = point.x;
                if (point.x > maxX) maxX = point.x;
                if (point.y < minY) minY = point.y;
                if (point.y > maxY) maxY = point.y;

                points.push([point.x, point.y]);
            });

            var toAdd = {
                type: "polygon",
                label: label,
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                width: maxX - minX,
                height: maxY - minY,
                flipY: true,
                points: points
            };

            converted.boxes.push(toAdd);
        });
    });

    // parse if bbox format
    if (labelbox.Label && labelbox.Label.objects) {
        _.each(labelbox.Label.objects, function (object) {
            var bbox = object.bbox;
            if (!bbox) return;

            var toAdd = {
                label: object.value,
                x: bbox.left + bbox.width / 2,
                y: bbox.top + bbox.height / 2,
                width: bbox.width,
                height: bbox.height
            };
            if (object.color) toAdd.color = object.color;

            converted.boxes.push(toAdd);
        });
    }

    var ret = {
        key: [converted.key, labelbox["Labeled Data"]],
        original: original,
        converted: converted
    };

    ret.key = _.filter(ret.key);

    return ret;
};

Annotation.parseLabelBox2 = function (json, extension) {
    if(extension == "ndjson") {
        json = _.chain(json.split("\n")).map(function(row) {
            if(!row || !row.length) return null;
            return JSON.parse(row);
        }).filter().value();
    }

    var annotations = [];
    _.each(json, function (row) {
        annotations.push({
            labelBoxUrl: row?.data_row?.row_data,
            annotation: Annotation.parseLabelBox2Item(row)
        });
    });
    return annotations;
};

Annotation.parseLabelBox2Item = function (labelbox) {
    var original = {
        source: 'labelbox2',
        format: 'json',
        annotation: JSON.stringify(labelbox)
    };

    var converted = {
        key: labelbox?.data_row?.external_id?.split("/").pop(),
        boxes: []
    };

    _.each(labelbox?.projects, function(project, id) {
        _.each(project?.labels, function(label) {
            _.each(label?.annotations?.objects, function(annotation) {
                var box;
                if(annotation?.annotation_kind == "ImagePolygon") {
                    /*
                    {
                        "feature_id": "ckzxvowcg001f3968ptxtp5mo",
                        "feature_schema_id": "cks1cv8sd2orr0zd57xzcalg2",
                        "name": "Roof face",
                        "value": "roof_face",
                        "annotation_kind": "ImagePolygon",
                        "classifications": [],
                        "polygon": [
                            { "x": 272.181, "y": 153.656 },
                            { "x": 305.014, "y": 201.323 },
                            { "x": 360.014, "y": 164.823 },
                            { "x": 272.181, "y": 153.656 }
                        ]
                    }
                    */
                    var points = [];
                    var minX = Infinity;
                    var maxX = -Infinity;
                    var minY = Infinity;
                    var maxY = -Infinity;

                    _.each(annotation?.polygon, function (point) {
                        if (point.x < minX) minX = point.x;
                        if (point.x > maxX) maxX = point.x;
                        if (point.y < minY) minY = point.y;
                        if (point.y > maxY) maxY = point.y;

                        points.push([point.x, point.y]);
                    });

                    box = {
                        label: annotation?.value || annotation?.name || "object",
                        x: (minX + maxX) / 2,
                        y: (minY + maxY) / 2,
                        width: maxX - minX,
                        height: maxY - minY
                    };

                    if(points.length >= 3) {
                        box.type = "polygon";
                        box.points = points;
                    }

                    converted.boxes.push(box);
                } else if(annotation?.annotation_kind == "ImageBoundingBox") {
                    /*
                    {
                        "feature_id": "cltd6k45001ss14ysa9ygzkf0",
                        "feature_schema_id": "cltd6fbqp071w07u231uy8ajl",
                        "name": "bounding_box",
                        "value": "bounding_box",
                        "annotation_kind": "ImageBoundingBox",
                        "classifications": [],
                        "bounding_box": {
                            "top": 977.0,
                            "left": 1690.0,
                            "height": 330.0,
                            "width": 225.0
                        }
                    }
                    */
                    
                    box = {
                        label: annotation?.value || annotation?.name || "object",
                        x: annotation?.bounding_box?.left + annotation?.bounding_box?.width / 2,
                        y: annotation?.bounding_box?.top + annotation?.bounding_box?.height / 2,
                        width: annotation?.bounding_box?.width,
                        height: annotation?.bounding_box?.height
                    };

                    converted.boxes.push(box);
                }
            });
        });
    });

    var ret = {
        key: [converted.key, labelbox?.data_row?.row_data],
        original: original,
        converted: converted
    };

    ret.key = _.filter(ret.key);

    return ret;
};

var parseV7Item = function (label, bbox, pointsIn) {
    var minX = Infinity;
    var minY = Infinity;
    var maxX = -Infinity;
    var maxY = -Infinity;

    var points = [];

    _.each(pointsIn, function (point) {
        if (typeof point.x != "undefined" && typeof point.y != "undefined") {
            points.push([point.x, point.y]);

            if (point.x < minX) minX = point.x;
            if (point.x > maxX) maxX = point.x;
            if (point.y < minY) minY = point.y;
            if (point.y > maxY) maxY = point.y;
        }
    });

    var ret = {
        label: label,
        x: (minX + maxX) / 2,
        y: (minY + maxY) / 2,
        width: maxX - minX,
        height: maxY - minY
    }

    if (points.length > 2) {
        ret.type = "polygon";
        ret.points = points;
    } else if (bbox) {
        // malformed polygon; fall back to bbox;
        ret.x = bbox.x + bbox.w / 2;
        ret.y = bbox.y + bbox.h / 2;
        ret.width = bbox.w;
        ret.height = bbox.h;
    } else {
        return null;
    }

    return ret;
};

Annotation.parseV7Labs = function (v7) {
    var original = {
        source: 'v7labs',
        format: 'json',
        annotation: JSON.stringify(v7)
    };

    var fname = v7.image?.filename || v7.item?.name;
    var keys = [fname];
    if (fname.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        // gun dataset fix
        keys.push(fname + ".jpg");
        keys.push(fname + ".jpeg");
        keys.push(fname + ".png");
        keys.push(fname + ".bmp");
    }

    var converted = {
        key: fname,
        boxes: []
    };

    // parse if points format
    _.each(v7.annotations, function (a) {
        if (a.complex_polygon) {
            _.each(a.complex_polygon.path, function (points) {
                // don't pass the parent bbox here because it's of the full complex_polygon
                // not this sub-polygon
                var parsed = parseV7Item(a.name, null, points);
                if (parsed) converted.boxes.push(parsed);
            });
        } else {
            var parsed = parseV7Item(a.name, a.bounding_box, a.polygon && a.polygon.path);
            if (parsed) converted.boxes.push(parsed);
        }
    });

    var ret = {
        key: keys,
        original: original,
        converted: converted
    };

    return ret;
};

Annotation.parseV7Darwin = function (v7) {
    var original = {
        source: 'v7darwin',
        format: 'json',
        annotation: JSON.stringify(v7)
    };

    var fname = v7.item.name;
    var keys = [fname];

    // looks like sometimes they sanitize dashes to underscores &
    // then the filename doesn't match; so un-sanitize it & try that too
    _.each(keys, function(key) {
        if(key.indexOf("_") >= 0) {
            keys.push(key.replace(/_/g, "-"));
        }
    });

    var converted = {
        key: fname,
        boxes: []
    };

    // parse if points format
    _.each(v7.annotations, function (a) {
        if (a.complex_polygon) {
            _.each(a.complex_polygon.path, function (points) {
                // don't pass the parent bbox here because it's of the full complex_polygon
                // not this sub-polygon
                var parsed = parseV7Item(a.name, null, points);
                if (parsed) converted.boxes.push(parsed);
            });
        } else {
            var parsed = parseV7Item(a.name, a.bounding_box, a.polygon?.path || (a.polygon && _.flatten(a.polygon?.paths)));
            if (parsed) converted.boxes.push(parsed);
        }
    });

    var ret = {
        key: keys,
        original: original,
        converted: converted
    };

    return ret;
};

Annotation.parseCogniac = function (cogniac) {
    var ret = [];

    _.each(cogniac.images, function(image) {
        var original = {
            source: 'Cogniac',
            format: 'json',
            annotation: JSON.stringify(image)
        };
    
        var fname = image.filename.split(/\/|\\/).pop();
        var keys = [fname];
        if (fname.indexOf(".") < 0) {
            // they didn't include the extension.. match any we support
            // gun dataset fix
            keys.push(fname + ".jpg");
            keys.push(fname + ".jpeg");
            keys.push(fname + ".png");
            keys.push(fname + ".bmp");
        }

        var converted = {
            key: fname,
            boxes: []
        };
    
        var text = "";
        var drill = function(value, key) {
            if(_.isPlainObject(value)) {
                if(value["x0"]) {
                    var label = _.isNumber(key) ? text : key;
                    converted.boxes.push({
                        label: label,
                        x: (value["x1"] + value["x0"])/2,
                        y: (value["y1"] + value["y0"])/2,
                        width: value["x1"] - value["x0"],
                        height: value["y1"] - value["y0"]
                    })
                } else {
                    return _.each(value, drill);
                }
            } else if(_.isArray(value)) {
                text = key;
                _.each(value, drill);
            } else {
                // do nothing; leaf node like "frame" or "filename"
            }
        };

        drill(image, "object");

        ret.push({
            key: keys,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parseLabelBoxVideo = function (labelbox, extension, fname) {
    var ret = [];

    try {
        labelbox = JSON.parse(labelbox);
    } catch (e) {
        try {
            // sometimes these are JSONL (tests/labelbox.video.jsonl.json)
            var split = labelbox.split("\n")
            split.pop();
            labelbox = JSON.parse("[" + split.join(",\n") + "]");
        } catch (e) {
            // sometimes they are expanded JSONL (wtf) (tests/labelbox.video.expanded-jsonl.json)
            var split = labelbox.split("\n}")
            split.pop();
            labelbox = JSON.parse("[" + split.join("\n},") + "}]");
        }
    }

    _.each(labelbox, function (labelbox) {
        var original = {
            source: 'labelboxvideo',
            format: 'json',
            annotation: JSON.stringify(labelbox)
        };

        // name: video.name.replace(/\./g, "_") + "-" + i + ".jpg"
        var converted = {
            key: fname,
            boxes: []
        };

        // parse if objects format
        _.each(labelbox.objects, function (object) {
            var bbox = object.bbox;
            if (!bbox) return;

            var toAdd = {
                label: object.value,
                x: bbox.left + bbox.width / 2,
                y: bbox.top + bbox.height / 2,
                width: bbox.width,
                height: bbox.height
            };
            if (object.color) toAdd.color = object.color;

            converted.boxes.push(toAdd);
        });

        // parse if points format
        _.each(labelbox.Label, function (geometries, label) {
            _.each(geometries, function (geometryContainer) {
                if (!geometryContainer.geometry || geometryContainer.geometry.length == 0) return;
                var geometry = geometryContainer.geometry;

                var minX = Infinity;
                var maxX = -Infinity;
                var minY = Infinity;
                var maxY = -Infinity;

                _.each(geometry, function (point) {
                    if (point.x < minX) minX = point.x;
                    if (point.x > maxX) maxX = point.x;
                    if (point.y < minY) minY = point.y;
                    if (point.y > maxY) maxY = point.y;
                });

                converted.boxes.push({
                    label: label,
                    x: (minX + maxX) / 2,
                    y: (minY + maxY) / 2,
                    width: maxX - minX,
                    height: maxY - minY,
                    flipY: true
                });
            });
        });

        // parse if bbox format
        if (labelbox.Label && labelbox.Label.objects) {
            _.each(labelbox.Label.objects, function (object) {
                var bbox = object.bbox;
                if (!bbox) return;

                var toAdd = {
                    label: object.value,
                    x: bbox.left + bbox.width / 2,
                    y: bbox.top + bbox.height / 2,
                    width: bbox.width,
                    height: bbox.height
                };
                if (object.color) toAdd.color = object.color;

                converted.boxes.push(toAdd);
            });
        }

        var toAdd = {
            key: [
                labelbox["Labeled Data"],
                fname + "_mp4-" + (labelbox["frameNumber"] - 1) + ".jpg",
                fname + "_mov-" + (labelbox["frameNumber"] - 1) + ".jpg",
                fname + "_f" + (labelbox["frameNumber"] - 1) + ".jpg"
            ],
            original: original,
            converted: converted
        };

        if (typeof labelbox["frameNumber"] != "undefined") toAdd.frame = labelbox["frameNumber"];

        toAdd.key = _.uniq(_.filter(toAdd.key));
        ret.push(toAdd);
    });

    return ret;
};

Annotation.parseSupervisely = function (supervisely, extension, filename) {
    var original = {
        source: 'supervisely',
        format: 'json',
        annotation: JSON.stringify(supervisely)
    };

    var converted = {
        key: filename,
        boxes: []
    };

    var keys = [filename];
    if (filename.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        keys.push(filename + ".jpg");
        keys.push(filename + ".jpeg");
        keys.push(filename + ".png");
        keys.push(filename + ".bmp");
    }

    _.each(supervisely.objects, function (object) {
        if (!object.points || !object.points.exterior || !object.points.exterior.length) return;

        var xmin = Infinity;
        var ymin = Infinity;
        var xmax = -Infinity;
        var ymax = -Infinity;

        _.each(object.points.exterior, function (point) {
            if (point[0] < xmin) xmin = point[0];
            if (point[0] > xmax) xmax = point[0];
            if (point[1] < ymin) ymin = point[1];
            if (point[1] > ymax) ymax = point[1];
        });

        var x = (xmin + xmax) / 2;
        var y = (ymin + ymax) / 2;

        var width = Math.abs(xmax - xmin);
        var height = Math.abs(ymax - ymin);

        var toAdd = {
            label: object.classTitle,
            x: x,
            y: y,
            width: width,
            height: height
        };

        if (object.geometryType == "polygon") {
            toAdd.type = "polygon";
            toAdd.points = object.points.exterior;
        }

        converted.boxes.push(toAdd);
    });

    var ret = {
        key: keys,
        original: original,
        converted: converted
    };

    return ret;
};

Annotation.parseLabelme = function (labelme, extension, filename) {
    var imageData = labelme.imageData;
    delete labelme.imageData;

    var original = {
        source: 'labelme',
        format: 'json',
        annotation: JSON.stringify(labelme)
    };

    var converted = {
        key: filename,
        boxes: []
    };

    var keys = [filename];
    if (filename.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        keys.push(filename + ".jpg");
        keys.push(filename + ".jpeg");
        keys.push(filename + ".png");
        keys.push(filename + ".bmp");
    }

    _.each(labelme.shapes, function (object) {
        if (!object.points) return;

        var xmin = Infinity;
        var ymin = Infinity;
        var xmax = -Infinity;
        var ymax = -Infinity;

        // not quite the same polygon definition
        if (object.shape_type == "circle" && object.points && object.points.length == 2) {
            var center = object.points[0];
            var edge = object.points[1];

            var radius = Math.sqrt((center[0] - edge[0]) * (center[0] - edge[0]) + (center[1] - edge[1]) * (center[1] - edge[1]));

            xmin = center[0] - radius;
            xmax = center[0] + radius;
            ymin = center[1] - radius;
            ymax = center[1] + radius;
        }

        _.each(object.points, function (point) {
            if (point[0] < xmin) xmin = point[0];
            if (point[0] > xmax) xmax = point[0];
            if (point[1] < ymin) ymin = point[1];
            if (point[1] > ymax) ymax = point[1];
        });

        var x = (xmin + xmax) / 2;
        var y = (ymin + ymax) / 2;

        var width = Math.abs(xmax - xmin);
        var height = Math.abs(ymax - ymin);

        var toAdd = {
            label: object.label,
            x: x,
            y: y,
            width: width,
            height: height
        };

        if (object.shape_type == "polygon") {
            toAdd.type = "polygon";
            toAdd.points = object.points;
        }

        converted.boxes.push(toAdd);
    });

    var ret = {
        key: keys,
        original: original,
        converted: converted
    };

    ret.imageData = imageData;

    return ret;
};

Annotation.parseSuperAnnotate = function (superannotate, extension, filename, labelmap) {
    var ret = [];

    // two file formats; one is an object where the images are the keys
    // the other is an array where the image is referenced in the filename
    if (_.isArray(superannotate)) {
        var imgFilename = filename.split("___")[0];
        var container = {};
        container[imgFilename] = superannotate;
        superannotate = container;
    }

    // a third file format where each image gets one json
    if (superannotate.metadata && superannotate.instances) {
        superannotate = {
            [superannotate.metadata.name]: superannotate.instances
        };
    }

    _.each(superannotate, function (boxes, image) {
        var original = {
            source: 'superannotate',
            format: 'json',
            annotation: JSON.stringify(boxes)
        };


        var converted = {
            key: image,
            boxes: []
        };

        var keys = [image];

        _.each(boxes, function (object) {
            if (!object.points) return;

            var xmin = Infinity;
            var ymin = Infinity;
            var xmax = -Infinity;
            var ymax = -Infinity;

            var points = object.points;
            if (typeof object.points.x1 != "undefined") {
                points = [
                    object.points.x1,
                    object.points.y1,
                    object.points.x2,
                    object.points.y2
                ];
            }

            _.each(points, function (point, i) {
                if (i % 2 == 0) {
                    // x point
                    if (point < xmin) xmin = point;
                    if (point > xmax) xmax = point;
                } else {
                    // y point
                    if (point < ymin) ymin = point;
                    if (point > ymax) ymax = point;
                }
            });

            var x = (xmin + xmax) / 2;
            var y = (ymin + ymax) / 2;

            var width = Math.abs(xmax - xmin);
            var height = Math.abs(ymax - ymin);

            var label = object.className || ("" + object.classId);
            
            var toAdd = {
                label: label,
                x: x,
                y: y,
                width: width,
                height: height
            };

            if (object.type == "polygon" || object.type == "polyline") {
                toAdd.type = "polygon";
                toAdd.points = _.chunk(points, 2);
            }

            converted.boxes.push(toAdd);
        });

        ret.push({
            key: keys,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parseCloudAnnotations = function (cloudannotations, extension, filename, labelmap) {
    var ret = [];

    _.each(cloudannotations.annotations, function (boxes, image) {
        var original = {
            source: 'cloudannotations',
            format: 'json',
            annotation: JSON.stringify(boxes)
        };

        var converted = {
            key: image,
            boxes: []
        };

        var keys = [image];

        _.each(boxes, function (object) {
            var xmin = object.x;
            var ymin = object.y;
            var xmax = object.x2;
            var ymax = object.y2;

            var x = (xmin + xmax) / 2;
            var y = (ymin + ymax) / 2;

            var width = Math.abs(xmax - xmin);
            var height = Math.abs(ymax - ymin);

            var label = "" + object.label;
            
            var toAdd = {
                label: label,
                x: x,
                y: y,
                width: width,
                height: height
            };

            converted.boxes.push(toAdd);
        });

        ret.push({
            key: keys,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parseUnity = function (unity, extension, filename, labelmap) {
    var ret = [];

    _.each(unity.captures, function (a) {
        var original = {
            source: 'unity',
            format: 'json',
            annotation: JSON.stringify(a)
        };

        var image = a.filename.split("/").pop();

        var converted = {
            key: image,
            boxes: []
        };

        var keys = [image];

        _.each(a.annotations[0].values, function (object) {
            var label = "" + object.label_name;
            
            var toAdd = {
                label: label,
                x: object.x + object.width / 2,
                y: object.y + object.height / 2,
                width: object.width,
                height: object.height
            };

            converted.boxes.push(toAdd);
        });

        ret.push({
            key: keys,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parsePKLot = function (text, extension, fname) {
    var xml;
    if (IS_BROWSER) {
        xml = $($.parseXML(text));
    } else {
        $ = cheerio.load(text);
        xml = $.root();
    }

    var filename = xml.find('filename').text();
    // fix if filename contains full path
    var filename_parts = filename.split("/");
    filename = filename_parts[filename_parts.length - 1];

    var converted = {
        key: filename,
        boxes: []
    };

    xml.find('contour').each(function () {
        var minX = Infinity;
        var minY = Infinity;
        var maxX = -Infinity;
        var maxY = -Infinity;

        var points = $(this).find('point');
        if (!points.length) return;

        var pointsParsed = [];
        points.each(function () {
            var x = parseFloat($(this).attr('x'));
            var y = parseFloat($(this).attr('y'));

            if (x > maxX) maxX = x;
            if (x < minX) minX = x;
            if (y > maxY) maxY = y;
            if (y < minY) minY = y;

            pointsParsed.push([x, y]);
        });

        var label = $(this).parent().prop('tagName');
        if ($(this).parent().attr('occupied') == "1") {
            label = label + "-occupied";
        } else {
            label = label + "-empty";
        }

        converted.boxes.push({
            type: "polygon",
            label: label,
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            width: maxX - minX,
            height: maxY - minY,
            points: pointsParsed
        });
    });

    var keys = [filename];
    if (filename.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        // gun dataset fix
        keys.push(filename + ".jpg");
        keys.push(filename + ".jpeg");
        keys.push(filename + ".png");
        keys.push(filename + ".bmp");
    }

    if (fname) {
        // also match the name of the xml
        // because some labeling tools really suck
        keys.push(fname + ".jpg");
        keys.push(fname + ".jpeg");
        keys.push(fname + ".png");
        keys.push(fname + ".bmp");
    }

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'PKLot',
            format: 'xml',
            annotation: text
        }
    };

    return ret;
};

Annotation.parseRectLabel = function (text, extension, fname) {
    var xml;
    if (IS_BROWSER) {
        xml = $(text);
    } else {
        $ = cheerio.load(text);
        xml = $.root();
    }

    var filename = xml.find('filename').text();
    // fix if filename contains full path
    var filename_parts = filename.split("/");
    filename = filename_parts[filename_parts.length - 1];

    var width = xml.find('size width').text() || xml.find('imagesize ncols').text();
    var height = xml.find('size height').text() || xml.find('imagesize nrows').text();

    var converted = {
        key: filename,
        width: width,
        height: height,
        boxes: []
    };

    xml.find('object').each(function () {
        // subtract 1 because VOC XML's top-left pixel is 1,1
        var minX = (parseFloat($(this).find('xmin').text()) - 1);
        var maxX = (parseFloat($(this).find('xmax').text()) - 1);
        var minY = (parseFloat($(this).find('ymin').text()) - 1);
        var maxY = (parseFloat($(this).find('ymax').text()) - 1);

        if (_.isNaN(minX)) minX = Infinity;
        if (_.isNaN(maxX)) maxX = -Infinity;
        if (_.isNaN(minY)) minY = Infinity;
        if (_.isNaN(maxY)) maxY = -Infinity;

        // see if this is a polygon
        var points = [];
        if ($(this).find('polygon pt').length) {
            $(this).find('polygon pt').each(function () {
                var x = parseFloat($(this).find('x').text()) - 1;
                var y = parseFloat($(this).find('y').text()) - 1;

                if (x > maxX) maxX = x;
                if (x < minX) minX = x;
                if (y > maxY) maxY = y;
                if (y < minY) minY = y;

                points.push([x, y]);
            });
        } else if ($(this).find('polygon x1').length) {
            var isX = true;
            var toAdd = [];
            $(this).find('polygon').children().each(function () {
                var val = $(this).text() - 1;

                // alternate between x & y (x1 y1 x2 y2 etc)
                if (isX) {
                    if (val > maxX) maxX = val;
                    if (val < minX) minX = val;

                    toAdd.push(val);
                } else {
                    if (val > maxY) maxY = val;
                    if (val < minY) minY = val;

                    toAdd.push(val);
                    points.push(toAdd);
                    toAdd = [];
                }

                isX = !isX;
            });
        }

        var box = {
            label: $(this).find('name').text(),
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            width: maxX - minX,
            height: maxY - minY
        };

        if (points.length) {
            box.type = "polygon";
            box.points = points;
        }

        converted.boxes.push(box);
    });

    var keys = [filename];
    if (filename.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        // gun dataset fix
        keys.push(filename + ".jpg");
        keys.push(filename + ".jpeg");
        keys.push(filename + ".png");
        keys.push(filename + ".bmp");
    }

    if (fname) {
        // also match the name of the xml
        // because some labeling tools really suck
        keys.push(fname + ".jpg");
        keys.push(fname + ".jpeg");
        keys.push(fname + ".png");
        keys.push(fname + ".bmp");
    }

    var extra = null;
    xml.find('metadata').each(function () {
        extra = { ...extra };
        $(this).find("tags").each(function () {
            if (!extra.user_tags) extra.user_tags = []
            $(this).find('tag').each(function () {
                extra.user_tags.push($(this).text());
            });
            extra.user_tags = _.uniq(extra.user_tags);
        });
    });

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'RectLabel',
            format: 'xml',
            annotation: text
        },
        extra: extra
    };

    return ret;
};

// http://www.icst.pku.edu.cn/cpdp/sjzy/index.htm
Annotation.parseMarmot = function (text, extension, fname) {
    var xml;
    if (IS_BROWSER) {
        xml = $('<container>' + text + '</container>');
    } else {
        $ = cheerio.load('<container>' + text + '</container>', {
            xmlMode: true
        });
        xml = $.root();
    }

    fname = fname.replace('_phy', ''); // unknown why annotations are all _phy.xml
    var filename = fname + ".jpg";

    var converted = {
        key: filename,
        boxes: []
    };

    var cb = xml.find('Page').attr('CropBox');
    if (!cb) {
        return {
            key: [],
            converted: converted,
            original: {
                source: 'Marmot',
                format: 'xml',
                annotation: text
            }
        };
    }

    var cropBox = _.map(cb.split(" "), function (str) {
        return convertHexToDouble(str);
    });
    var width = cropBox[2] - cropBox[0];
    var height = cropBox[1] - cropBox[3];

    xml.find('Composite').each(function () {
        var bbox = $(this).attr('BBox').split(" ");

        var minX = convertHexToDouble(bbox[0]) / width;
        var maxX = convertHexToDouble(bbox[2]) / width;
        var minY = convertHexToDouble(bbox[3]) / height;
        var maxY = convertHexToDouble(bbox[1]) / height;

        converted.boxes.push({
            label: $(this).attr('Label'),
            x: (minX + maxX) / 2,
            y: 1 - (minY + maxY) / 2,
            width: maxX - minX,
            height: maxY - minY
        });
    });

    var keys = [filename];

    if (fname) {
        // also match .jpeg and .png
        keys.push(fname + ".jpeg");
        keys.push(fname + ".png");
        keys.push(fname + ".bmp");
    }

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'Marmot',
            format: 'xml',
            annotation: text
        }
    };

    return ret;
};

Annotation.parseYoloKeras = function (text, _e, _f, labelmap) {
    var lines = text.split("\n");

    var columns = {
        label: 4,
        xmin: 0,
        ymin: 1,
        xmax: 2,
        ymax: 3
    };

    var files = {};
    var originals = {};
    _.each(lines, function (line) {
        var fields = line.split(/\s+/);

        fields = _.map(fields, function (field) {
            return field.trim().replace(/"/g, "");
        });

        var filename = fields[0];
        if (!filename) return;
        if (!files[filename]) {
            files[filename] = [];
            originals[filename] = [];
        }

        var _fields = fields;
        _.times(fields.length, function (i) {
            if (!i || !_fields[i]) return;

            var fields = _fields[i].split(',');
            if (!fields.length) return;

            var minX = parseFloat(fields[columns.xmin]);
            var maxX = parseFloat(fields[columns.xmax]);
            var minY = parseFloat(fields[columns.ymin]);
            var maxY = parseFloat(fields[columns.ymax]);

            var l = fields[columns.label];
            var box = {
                label: l,
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                width: maxX - minX,
                height: maxY - minY
            };

            files[filename].push(box);
        });

        originals[filename].push(line);
    });

    var ret = [];

    _.each(files, function (boxes, filename) {
        var converted = {
            key: filename,
            boxes: boxes
        };

        var keys = [filename];
        if (filename.indexOf(".") < 0) {
            // they didn't include the extension.. match any we support
            // gun dataset fix
            keys.push(filename + ".jpg");
            keys.push(filename + ".jpeg");
            keys.push(filename + ".png");
            keys.push(filename + ".bmp");
        }

        ret.push({
            key: keys,
            converted: converted,
            original: {
                source: 'YoloDarknet',
                format: 'txt',
                annotation: originals[filename].join("\n")
            }
        });
    });

    return ret;
};

Annotation.parseYoloDarknet = function (text, extension, fname, labelmap) {
    var filename = fname + ".jpg";
    var converted = {
        key: filename,
        boxes: []
    };

    var keys = [filename];
    if (fname) {
        // also match .jpeg and .png
        keys.push(fname + ".jpeg");
        keys.push(fname + ".png");
        keys.push(fname + ".bmp");
    }

    var lines = text.split("\n");

    var columns = {
        label: 0,
        x: 1,
        y: 2,
        w: 3,
        h: 4
    };

    _.each(lines, function (line) {
        if (!line) return;

        var fields = line.split(" ");

        fields = _.map(fields, function (field) {
            return field.trim().replace(/"/g, "");
        });

        var l = fields[columns.label];
        var label = l;

        var box;

        if (fields.length >= 7) {
            // polygon

            var minX = Infinity;
            var minY = Infinity;
            var maxX = -Infinity;
            var maxY = -Infinity;

            var x, y;
            var points = [];
            for (var i = 1; i < fields.length; i += 2) {
                x = parseFloat(fields[i]);
                y = parseFloat(fields[i + 1]);

                if (x > maxX) maxX = x;
                if (y > maxY) maxY = y;
                if (x < minX) minX = x;
                if (y < minY) minY = y;

                points.push([x, y]);
            }

            box = {
                label: label,
                type: "polygon",
                x: (minX + maxX) / 2,
                y: (minY + maxY) / 2,
                width: (maxX - minX),
                height: (maxY - minY),
                points: points
            };
        } else {
            // bounding box
            box = {
                label: label,
                x: parseFloat(fields[columns.x]),
                y: parseFloat(fields[columns.y]),
                width: parseFloat(fields[columns.w]),
                height: parseFloat(fields[columns.h])
            };
        }

        converted.boxes.push(box);
    });

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'YoloDarknet',
            format: 'txt',
            annotation: text
        }
    };

    return ret;
};

Annotation.parseOpenImage = function (text, extension, fname, labelmap) {
    var filename = fname + ".jpg";
    var converted = {
        key: filename,
        boxes: []
    };

    var keys = [filename];
    if (fname) {
        // also match .jpeg and .png
        keys.push(fname + ".jpeg");
        keys.push(fname + ".png");
        keys.push(fname + ".bmp");
    }

    var lines = text.split("\n");

    var columns = {
        label: 0,
        x1: 1,
        y1: 2,
        x2: 3,
        y2: 4
    };

    _.each(lines, function (line) {
        if (!line) return;

        var fields = line.split(" ");
        var parsed_fields = [];
        var logged_label = false;
        var label = [];
        //Open images Lables may come with any number of spaces in the name e.g. "Ac power plugs and socket-outlets"

        fields.forEach(function (value) {
            if (isNaN(value)) {
                label.push(value);
            }
            else {
                if (!logged_label) {
                    parsed_fields.push(label.join("-"));
                    logged_label = true;
                }
                parsed_fields.push(value);
            }
        });
        fields = parsed_fields;

        fields = _.map(fields, function (field) {
            return field.trim().replace(/"/g, "");
        });

        var l = fields[columns.label];

        width = parseFloat(fields[columns.x2]) - parseFloat(fields[columns.x1]);
        height = parseFloat(fields[columns.y2]) - parseFloat(fields[columns.y1]);

        var box = {
            label: l,
            x: parseFloat(fields[columns.x1]) + width / 2,
            y: parseFloat(fields[columns.y1]) + height / 2,
            width: width,
            height: height
        };

        converted.boxes.push(box);
    });

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'OpenImage',
            format: 'txt',
            annotation: text
        }
    };

    return ret;
};

Annotation.parseCOCO = function (json, defaultName) {
    var files = {};
    var originals = {};
    _.each(json.images, function (image) {
        var id = image.id;
        var filename = image.file_name;
        if (!filename || typeof id == "undefined") return;
        if (!files[id]) {
            files[id] = {
                image: image,
                annotations: []
            };
            originals[id] = [];
        }
    });

    var categories = {};
    var max_cat = 0;
    _.each(json.categories, function (category) {
        categories[category.id] = category.name;
        if (category.id > max_cat) max_cat = category.id;
    });

    max_cat++;
    categories[max_cat] = defaultName;

    _.each(json.annotations, function (annotation) {
        var id = annotation.image_id;
        if (typeof id == "undefined") return;
        if (!files[id]) return;
        if (!annotation.bbox || annotation.bbox.length != 4) return;

        var left, right, top, bottom, box, points, width, height;

        var label;
        var category_id = annotation.category_id;
        if (category_id === 0) {
            label = categories[annotation.category_id];
        } else {
            label = categories[annotation.category_id || max_cat];
        }

        var attributes;
        if (
            annotation.extra && 
            annotation.extra.attributes && 
            _.isArray(annotation.extra.attributes) &&
            annotation.extra.attributes.length > 0 &&
            _.every(annotation.extra.attributes, _.isString)
        ) {
            attributes = annotation.extra.attributes;
        }

        const annotationKeypoints = annotation.keypoints || [];
        // keypoints are stored as [p0x, p0y, p0visibility, ...]
        const keypointGroups = Array.from({length: annotationKeypoints.length/3}, (_, i) => annotationKeypoints.slice(i*3, i*3+3));
        const keypoints =  keypointGroups.map((keypointGroup, index)=>{
            const keypoint = {
                x: keypointGroup[0],
                y: keypointGroup[1],
                id: index
            };
            if (keypointGroup[2] === 1) keypoint.occluded = true;
            if (keypointGroup[2] === 0) keypoint.deleted = true;

            return keypoint;
        });

        // convert COCO RLE mask to polygon
        if (annotation.segmentation && _.isPlainObject(annotation.segmentation) && annotation.segmentation.counts && annotation.segmentation.size) {
            var polygons = [];
            var points = [];
            const h = annotation.segmentation.size[0];
            const w = annotation.segmentation.size[1];

            var cursorY = 0;
            var cursorX = 0;

            const end = h * w;
            var c;
            var i = 0;
            var xDelta;
            var yToUse;

            // ignore the last point because it's all zeros & so always "ends" in the corner
            while (i < annotation.segmentation.counts.length - 1) {
                c = annotation.segmentation.counts[i];

                xDelta = Math.floor((cursorY + c) / h);

                cursorX += xDelta;
                cursorY = (cursorY + c) % h;

                if (xDelta > 1) {
                    // split completely disjoint shapes
                    if (points.length > 3) polygons.push(points);
                    points = [];
                }

                // this fixes an overflow pixel from making shapes that touch
                // the top or bottom from inverting
                if (i % 2 && xDelta == 1 && cursorY == 0) {
                    yToUse = h;
                } else if (!i % 2 && xDelta == 1 && cursorY == h) {
                    yToUse = 0;
                } else {
                    yToUse = cursorY;
                }

                // add points between long segments at the begining and end so they don't get concaved away
                if ((i == 1 || i % 2 && i == annotation.segmentation.counts.length - 1) && xDelta == 0 && c >= 10) {
                    for (var j = 1; j < Math.floor(c / 5); j++) {
                        points.push([cursorX, yToUse - 5 * j]);
                    }
                }

                // add the actual point we want
                points.push([cursorX, yToUse]);

                i++;
            }

            // add last in-progress polygon
            if (points.length >= 3) polygons.push(points);

            // simplify the shapes so we don't have a vertex at every point along the edge
            annotation.segmentation = _.map(polygons, function (polygon) {
                // sort points so closest ones are nearest each other to assist simplifyMultiPolygon
                var closestIndex;
                var closestDistance;
                var cursor, next, distance, placeholder, i, j;
                for (i = 0; i < polygon.length - 1; i++) {
                    cursor = polygon[i];
                    closestIndex = i + 1;
                    closestDistance = Infinity;

                    // find closest point spatially
                    for (j = i + 1; j < polygon.length; j++) {
                        next = polygon[j];
                        distance = Math.sqrt((cursor[0] - next[0]) * (cursor[0] - next[0]) + (cursor[1] - next[1]) * (cursor[1] - next[1]));
                        if (distance < closestDistance) {
                            closestDistance = distance;
                            closestIndex = j;
                        }
                    }

                    // swap closest point with the next position in the array
                    placeholder = polygon[closestIndex];
                    polygon[closestIndex] = polygon[i + 1];
                    polygon[i + 1] = placeholder;
                }

                // simplify to reduce number of vertices; we will compress down multipolygons into single polygons later
                return _.flatten( // convert to [x, y, x, y] instead of [[x, y], [x, y]]
                    Annotation.simplifyMultiPolygon(
                        [_.flatten(polygon)], 1, 1.5 // settings chosen by trial and error
                    )[0] // we just want the points
                );
            });
        }

        // ensure it's an array of arrays (vs [1,2,3] which is not valid COCO) & filter out empty sections so eg [[]] gets ignored & treated as object detection
        if (annotation.segmentation && annotation.segmentation.length) {
            if (!_.isArray(annotation.segmentation[0])) annotation.segmentation = [annotation.segmentation];
            annotation.segmentation = _.filter(annotation.segmentation, _.size);
        }

        if (annotation.segmentation && annotation.segmentation.length > 1) {
            // if this object has multiple disjoint segmentation masks, combine
            // them using a concave hull of the edge points

            var [points, box] = Annotation.simplifyMultiPolygon(annotation.segmentation);

            left = box.left;
            right = box.right;
            top = box.top;
            bottom = box.bottom;
            width = box.width;
            height = box.height;

            box = {
                type: "polygon",
                label: label,
                x: left + width / 2,
                y: top + height / 2,
                width: width,
                height: height,
                points: points
            };

            if (attributes) box.attributes = attributes;

            if (keypoints) box.keypoints = keypoints;

            files[id].annotations.push(box);
            originals[id].push(annotation);
        } else if (annotation.segmentation && annotation.segmentation.length) {
            // if a single polygon, use the points without transforming them
            left = Infinity;
            right = -Infinity;
            top = Infinity;
            bottom = -Infinity;

            var segmentation = annotation.segmentation[0];

            var points = [];
            var x, y;
            for (var i = 0; i <= segmentation.length - 2; i += 2) {
                x = segmentation[i];
                y = segmentation[i + 1];

                if (x < left) left = x;
                if (x > right) right = x;
                if (y > bottom) bottom = y;
                if (y < top) top = y;

                points.push([x, y]);
            }

            if (points.length < 3) {
                // we don't allow line segments, only polygons; skip
                return;
            }

            width = right - left;
            height = bottom - top;

            box = {
                type: "polygon",
                label: label,
                x: left + width / 2,
                y: top + height / 2,
                width: width,
                height: height,
                points: points
            };

            if (attributes) box.attributes = attributes;

            if (keypoints) box.keypoints = keypoints;

            files[id].annotations.push(box);
            originals[id].push(annotation);
        } else {
            // no segmentation mask, use bounding box
            left = annotation.bbox[0];
            top = annotation.bbox[1];
            width = annotation.bbox[2];
            height = annotation.bbox[3];

            box = {
                label: label,
                x: left + width / 2,
                y: top + height / 2,
                width: width,
                height: height
            };

            if (attributes) box.attributes = attributes;

            if (keypoints) box.keypoints = keypoints;

            files[id].annotations.push(box);
            originals[id].push(annotation);
        }
    });

    var ret = [];

    _.each(files, function (info, id) {
        var splits = info.image.file_name.split("/");
        var filename = splits[splits.length - 1];
        var boxes = info.annotations;

        var converted = {
            key: filename,
            boxes: boxes
        };

        var keys = [filename];
        if (filename.indexOf(".") < 0) {
            // they didn't include the extension.. match any we support
            // gun dataset fix
            keys.push(filename + ".jpg");
            keys.push(filename + ".jpeg");
            keys.push(filename + ".png");
            keys.push(filename + ".bmp");
        }

        var extra = null;
        if (info.image.extra) {
            extra = info.image.extra;
        }

        ret.push({
            key: keys,
            converted: converted,
            original: {
                source: 'coco',
                format: 'json',
                annotation: JSON.stringify(originals[id])
            },
            extra: extra,
        });
    });

    return ret;
};

Annotation.parseRoboflowPrediction = function (json, extension, filename) {
    var converted = {
        key: filename,
        boxes: []
    };

    _.each(json.predictions, function (box) {
        converted.boxes.push({
            x: box.x,
            y: box.y,
            width: box.width,
            height: box.height,
            label: box.class
        });
    })

    var keys = [filename];
    if (filename.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        // gun dataset fix
        keys.push(filename + ".jpg");
        keys.push(filename + ".jpeg");
        keys.push(filename + ".png");
        keys.push(filename + ".bmp");
    }

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'RoboflowPrediction',
            format: 'json',
            annotation: JSON.stringify(json)
        }
    };

    return ret;
};

Annotation.parseVOTT = function (json, defaultName) {
    var filename = json.asset.name;

    var converted = {
        key: filename,
        boxes: []
    };

    _.each(json.regions, function (region) {
        var toAdd = {
            label: region.tags[0],
            x: region.boundingBox.left + region.boundingBox.width / 2,
            y: region.boundingBox.top + region.boundingBox.height / 2,
            width: region.boundingBox.width,
            height: region.boundingBox.height
        };

        if (region.type == "POLYGON") {
            toAdd.type = "polygon";
            toAdd.points = _.map(region.points, function (p) {
                return [p.x, p.y];
            });
        }

        converted.boxes.push(toAdd);
    });

    var keys = [filename];
    if (filename.indexOf(".") < 0) {
        // they didn't include the extension.. match any we support
        // gun dataset fix
        keys.push(filename + ".jpg");
        keys.push(filename + ".jpeg");
        keys.push(filename + ".png");
        keys.push(filename + ".bmp");
    }

    var ret = {
        key: keys,
        converted: converted,
        original: {
            source: 'VOTT',
            format: 'json',
            annotation: JSON.stringify(json)
        }
    };

    return ret;
};

Annotation.parseVOTTVideo = function (json, defaultName) {
    var ret = [];

    _.each(json.assets, function (asset) {
        ret.push(Annotation.parseVOTT(asset));
    });

    return ret;
};

Annotation.parseUdacity = function (text) {
    var lines = text.split("\n");
    // var headers = lines.shift().split(",");
    // headers = _.map(headers, function(header) {
    //     return header.trim();
    // });

    // default for Tensorflow Object Detection
    var columns = {
        file: 0,
        label: 6,
        xmin: 1,
        ymin: 2,
        xmax: 3,
        ymax: 4
    };

    var files = {};
    var originals = {};
    _.each(lines, function (line) {
        var fields = line.split(" ");
        if (fields.length < 7) return;

        fields = _.map(fields, function (field) {
            return field.trim().replace(/"/g, "");
        });

        if (fields.length == 8) fields[6] += "-" + fields[7];

        var filename = fields[columns.file];
        if (!filename) return;
        if (!files[filename]) {
            files[filename] = [];
            originals[filename] = [];
        }

        var minX = parseFloat(fields[columns.xmin]);
        var maxX = parseFloat(fields[columns.xmax]);
        var minY = parseFloat(fields[columns.ymin]);
        var maxY = parseFloat(fields[columns.ymax]);

        var box = {
            label: fields[columns.label],
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            width: maxX - minX,
            height: maxY - minY
        };

        files[filename].push(box);
        originals[filename].push(line);
    });

    var ret = [];

    _.each(files, function (boxes, filename) {
        var converted = {
            key: filename,
            boxes: boxes
        };

        var keys = [filename];
        if (filename.indexOf(".") < 0) {
            // they didn't include the extension.. match any we support
            // gun dataset fix
            keys.push(filename + ".jpg");
            keys.push(filename + ".jpeg");
            keys.push(filename + ".png");
            keys.push(filename + ".bmp");
        }

        ret.push({
            key: keys,
            converted: converted,
            original: {
                source: 'udacity',
                format: 'udacity2',
                annotation: originals[filename].join("\n")
            }
        });
    });

    return ret;
};

Annotation.parseGroundtruth = function (text) {
    var lines = text.split("\n");

    var files = {};
    var originals = {};
    _.each(lines, function (line) {
        if (!line || !line.length) return;

        var a = JSON.parse(line);
        if (!a["source-ref"] || line.indexOf("annotations") < 0) return;

        var filename = a["source-ref"].split("/").pop();
        if (!filename) return;
        if (!files[filename]) {
            files[filename] = [];
            originals[filename] = [];
        }

        _.each(a, function (v, k) {
            _.each(v.annotations, function (b) {
                var label = a[k + "-metadata"]["class-map"][b.class_id];
                var box = {
                    label: label,
                    x: b.left + b.width / 2,
                    y: b.top + b.height / 2,
                    width: b.width,
                    height: b.height
                };
                files[filename].push(box);
                originals[filename].push(line);
            });
        });
    });

    var ret = [];

    _.each(files, function (boxes, filename) {
        var converted = {
            key: filename,
            boxes: boxes
        };

        var keys = [filename];
        if (filename.indexOf(".") < 0) {
            // they didn't include the extension.. match any we support
            // gun dataset fix
            keys.push(filename + ".jpg");
            keys.push(filename + ".jpeg");
            keys.push(filename + ".png");
            keys.push(filename + ".bmp");
        }

        ret.push({
            key: keys,
            converted: converted,
            original: {
                source: 'Groundtruth',
                format: 'manifest',
                annotation: originals[filename].join("\n")
            }
        });
    });

    return ret;
};

Annotation.parseCSV = function (text) {
    var lines = text.split("\n");
    var headers = lines.shift().split(",");
    headers = _.map(headers, function (header) {
        return header.trim().replace(/"/g, "");
    });

    const firstLine = lines && lines[0];

    if (headers[0] == "filename" && firstLine && firstLine.match(/^([^,]+)(, *[01])+$/)) {
        return Annotation.parseCSVClassification(headers, lines);
    } else {
        return Annotation.parseCSVObjectDetection(headers, lines);
    }
}

Annotation.parseCSVClassification = function (headers, lines) {
    var ret = [];

    _.each(lines, function (line) {
        line = line.split(",");
        var filename = line.shift().trim();

        var original = {
            source: 'Multi-Label CSV',
            format: 'csv',
            annotation: [headers, line].join("\n")
        };

        var converted = {
            key: filename,
            boxes: []
        };

        _.each(line, function (present, i) {
            if (parseInt(present)) {
                converted.boxes.push({
                    label: headers[i + 1].trim(),
                    x: 0.5,
                    y: 0.5,
                    width: 1,
                    height: 1
                });
            }
        });

        ret.push({
            key: filename,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parseCSVObjectDetection = function (headers, lines) {
    // default for Tensorflow Object Detection
    var columns = {
        file: 0,
        label: 3,
        xmin: 4,
        ymin: 5,
        xmax: 6,
        ymax: 7
    };

    // AutoML CSV
    var isAutoML = false;
    if (lines[0].match(/.+,gs:\/\/.+,[0-9\.]*,[0-9\.]*,[0-9\.]*,[0-9\.]*,.+/)) {
        columns = {
            file: 1,
            label: 2,
            xmin: 3,
            ymin: 4,
            xmax: 7,
            ymax: 8
        };
        // no header
        lines.push(headers.join(","));
        isAutoML = true;
    }

    // RetinaNet Keras
    if (lines[0].match(/^[^,]+,[0-9]*,[0-9]*,[0-9]*,[0-9]*,[^,]+/)) {
        columns = {
            file: 0,
            label: 5,
            xmin: 1,
            ymin: 2,
            xmax: 3,
            ymax: 4
        };
        // no header
        lines.push(headers.join(","));
    }

    // open images
    if (headers[0] == "ImageID" && headers[1] == "Source" && headers[2] == "LabelName") {
        columns = {
            file: 0,
            label: 2,
            xmin: 4,
            ymin: 6,
            xmax: 5,
            ymax: 7
        };
    }

    var vggCSV = false;
    // VGG Image Annotator
    if (headers[0] == "filename" && headers[1] == "file_size" && headers[2] == "file_attributes" && headers[3] == "region_count" && headers[4] == "region_id") {
        vggCSV = true;

        columns = {
            file: 0,
            label: 1,
            xmin: 2,
            ymin: 3,
            xmax: 4,
            ymax: 5
        };
    }

    // VoTT CSV
    if (headers.join(", ") == "image, xmin, ymin, xmax, ymax, label") {
        columns = {
            file: 0,
            label: 5,
            xmin: 1,
            ymin: 2,
            xmax: 3,
            ymax: 4
        };
    }

    // Kaggle Wheat Competition
    var kaggleWheat = false;
    if (headers.join(",") == "image_id,width,height,bbox,source") {
        kaggleWheat = true;
        columns = {
            file: 0,
            label: 7,
            xmin: 3,
            ymin: 4,
            xmax: 5,
            ymax: 6
        };
    }

    if (headers.join(",") == "vehicleMake,vehicleModel,vehicleYear,vehicleNotes,imagePerspective,img_url,filename,class,width,height,xmin,ymin,xmax,ymax") {
        // RoboTire CSV
        columns = {
            url: 5,
            file: 6,
            label: 7,
            xmin: 10,
            ymin: 11,
            xmax: 12,
            ymax: 13
        };
    }

    if (headers.join(",") == "image,label,left,width,top,height") {
        // Kaggle NFL CSV
        columns = {
            file: 0,
            label: 1,
            xmin: 2,
            ymin: 4,
            xmax: function (l) { return parseFloat(l[2]) + parseFloat(l[3]); },
            ymax: function (l) { return parseFloat(l[4]) + parseFloat(l[5]); }
        };
    }

    // RetinaNet CSV

    var files = {};
    var originals = {};
    var urls = {};
    _.each(lines, function (line) {
        var fields;

        if (vggCSV) {
            line = line.replace(/""/g, "'");
            var c = line.match(/("[^"]*")|[^,]+/g);
            if (c.length != 7) return;

            var bbox = JSON.parse(c[5].replace(/"/g, "").replace(/'/g, '"'));

            var region_attributes = JSON.parse(c[6].replace(/"/g, "").replace(/'/g, '"'));
            fields = [
                c[0],
                region_attributes.shape || _.keys(region_attributes)[0],
                xmin(bbox) + bbox.width / 2,
                ymin(bbox) + bbox.height / 2,
                xmax(bbox) + bbox.width / 2,
                ymax(bbox) + bbox.height / 2
            ];
        } else if (kaggleWheat) {
            line = line.replace(/"|\[|\]|\s/g, "");
            fields = line.split(",");

            if (fields.length != 8) return;

            fields[5] = parseFloat(fields[3]) + parseFloat(fields[5]);
            fields[6] = parseFloat(fields[4]) + parseFloat(fields[6]);

            fields[7] = "wheat";
        } else {
            fields = line.split(",");
            if (fields.length < 6) return;

            fields = _.map(fields, function (field) {
                return field.trim().replace(/"/g, "");
            });
        }

        var filename = fields[columns.file];
        if (!filename) return;
        if (!files[filename]) {
            files[filename] = [];
            originals[filename] = [];
        }

        _.each(columns, function (v, col) {
            if (_.isFunction(v)) {

            }
        });

        var minX = _.isFunction(columns.xmin) ? columns.xmin(fields) : parseFloat(fields[columns.xmin]);
        var maxX = _.isFunction(columns.xmax) ? columns.xmax(fields) : parseFloat(fields[columns.xmax]);
        var minY = _.isFunction(columns.ymin) ? columns.ymin(fields) : parseFloat(fields[columns.ymin]);
        var maxY = _.isFunction(columns.ymax) ? columns.ymax(fields) : parseFloat(fields[columns.ymax]);

        var box = {
            label: fields[columns.label],
            x: (minX + maxX) / 2,
            y: (minY + maxY) / 2,
            width: Math.abs(maxX - minX),
            height: Math.abs(maxY - minY)
        };

        files[filename].push(box);
        originals[filename].push(line);

        if (columns.url) urls[filename] = fields[columns.url];
    });

    var ret = [];

    _.each(files, function (boxes, filename) {
        var parts;
        parts = filename.split(/\/|\\/);
        var fname = parts[parts.length - 1];

        var converted = {
            key: fname,
            boxes: boxes
        };

        var keys = [fname];
        if (fname.indexOf(".") < 0) {
            // they didn't include the extension.. match any we support
            // gun dataset fix
            keys.push(fname + ".jpg");
            keys.push(fname + ".jpeg");
            keys.push(fname + ".png");
            keys.push(fname + ".bmp");
        }

        if (isAutoML) {
            // strip timestamp
            keys.push(fname.replace(/-20[0-9][0-9]-[0-9][0-9]-[0-9][0-9]T[0-9][0-9]:[0-9][0-9]:[0-9][0-9].[0-9][0-9][0-9]Z/, ""));
        }

        var toAdd = {
            key: keys,
            converted: converted,
            original: {
                source: 'csv',
                format: 'csv',
                annotation: originals[filename].join("\n")
            }
        };

        if (urls[filename]) toAdd.url = urls[filename];

        ret.push(toAdd);
    });

    return ret;
};

Annotation.parseWiderFace = function (text) {
    var lines = text.split("\n");

    var ret = [];
    var cur = [], toAdd;

    lines.push("END OF FILE");

    _.each(lines, function (line) {
        if (line == "END OF FILE" || line.match(/.+\.(jpg|jpeg|png|bmp|tif|tiff)/i)) {
            // filename; start of new annotation
            if (toAdd) {
                toAdd.original.annotation = cur.join("\n");
                ret.push(toAdd);
            }

            var filename = line.split("/").pop(); // remove folder path

            cur = [];
            toAdd = {
                key: filename,
                converted: {
                    key: filename,
                    boxes: []
                },
                original: {
                    source: 'WiderFace',
                    format: 'txt'
                }
            };
        } else if (line.match(/[0-9]+ [0-9]+ [0-9]+ [0-9]+ 0|1 0|1 0|1 0|1 0|1 0|1/)) {
            // bbox
            var parts = line.split(" ");
            
            var box = {
                label: "face",
                x: parseInt(parts[0]) + parseInt(parts[2]) / 2,
                y: parseInt(parts[1]) + parseInt(parts[3] / 2),
                width: parseInt(parts[2]),
                height: parseInt(parts[3])
            };

            if(!isNaN(box.x) && !isNaN(box.y) && !isNaN(box.width) && !isNaN(box.height)) {
                toAdd.converted.boxes.push(box);
            }
        }

        cur.push(line);
    });

    return ret;
};

Annotation.parseCreateML = function (createml) {
    var ret = [];

    _.each(createml, function (createml) {
        var original = {
            source: 'createml',
            format: 'json',
            annotation: JSON.stringify(createml)
        };

        var converted = {
            key: createml.image,
            boxes: []
        };

        _.each(createml.annotations, function (annotation) {
            var coords = annotation.coordinates;
            converted.boxes.push({
                label: annotation.label,
                x: coords.x,
                y: coords.y,
                width: coords.width,
                height: coords.height
            });
        });

        ret.push({
            key: createml.image,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parseVIA = function (via) {
    var ret = [];

    if (via["_via_img_metadata"]) via = via["_via_img_metadata"];

    _.each(via, function (via, n) {
        var original = {
            source: 'via',
            format: 'json',
            annotation: JSON.stringify(via)
        };

        var converted = {
            key: via.filename,
            boxes: []
        };

        _.each(via.regions, function (annotation) {
            if (annotation.shape_attributes.name != "rect" && annotation.shape_attributes.name != "polygon") return;

            if (annotation.region_attributes && typeof annotation.region_attributes == "string") {
                annotation.region_attributes = JSON.parse(annotation.region_attributes);
            }

            let label = "object";
            let coords = annotation.shape_attributes;

            if (annotation.shape_attributes.name == "polygon") {
                let vals = _.keys(annotation.region_attributes);
                if (vals.length === 1) {
                    if (annotation.region_attributes[vals[0]].trim()) {
                        label = annotation.region_attributes[vals[0]].trim()
                    } else {
                        label = vals[0];
                    }
                }

                let x_min = _.min(coords.all_points_x);
                let x_max = _.max(coords.all_points_x);

                let y_min = _.min(coords.all_points_y);
                let y_max = _.max(coords.all_points_y);

                let width = x_max - x_min;
                let height = y_max - y_min;

                var points = [];
                for (var i = 0; i < coords.all_points_x.length; i++) {
                    points.push([coords.all_points_x[i], coords.all_points_y[i]]);
                }

                converted.boxes.push({
                    type: "polygon",
                    label: label,
                    x: x_min + width / 2,
                    y: y_min + height / 2,
                    width: width,
                    height: height,
                    points: points
                });
            } else {
                if (annotation.region_attributes) {
                    let vals = _.values(annotation.region_attributes);
                    if (vals.length === 1) {
                        label = vals[0];
                    } else if (annotation.region_attributes.shape) {
                        label = annotation.region_attributes.shape;
                    } else if (annotation.region_attributes.type) {
                        label = annotation.region_attributes.type;
                    } else if (vals.length) {
                        label = vals[0];
                    }
                }

                converted.boxes.push({
                    label: label,
                    x: coords.x + coords.width / 2,
                    y: coords.y + coords.height / 2,
                    width: coords.width,
                    height: coords.height
                });
            }
        });

        ret.push({
            key: via.filename,
            original: original,
            converted: converted
        });
    });

    return ret;
};

Annotation.parseScaleAI = function (scaleai) {
    // if you only export a single task it won't be an array
    if (!_.isArray(scaleai)) scaleai = [scaleai];

    return _.map(scaleai, function (scaleai) {
        var original = {
            source: 'scaleai',
            format: 'json',
            annotation: JSON.stringify(scaleai)
        };

        var converted = {
            key: _.filter([
                scaleai.params.attachment,
                scaleai.metadata && scaleai.metadata.filename
            ]),
            boxes: []
        };

        _.each(scaleai.response && scaleai.response.annotations, function (annotation) {
            if (annotation.type == "polygon") {
                var left = Infinity;
                var right = -Infinity;
                var top = Infinity;
                var bottom = -Infinity;

                var points = [];
                _.each(annotation.vertices, function (point) {
                    if (point.x < left) left = point.x;
                    if (point.x > right) right = point.x;
                    if (point.y > bottom) bottom = point.y;
                    if (point.y < top) top = point.y;

                    points.push([point.x, point.y]);
                });

                if (points.length < 3) {
                    // we don't allow line segments, only polygons; skip
                    return;
                }

                var width = right - left;
                var height = bottom - top;

                converted.boxes.push({
                    type: "polygon",
                    label: annotation.label,
                    x: left + width / 2,
                    y: top + height / 2,
                    width: width,
                    height: height,
                    points: points
                });
            } else {
                converted.boxes.push({
                    label: annotation.label,
                    x: annotation.left + annotation.width / 2,
                    y: annotation.top + annotation.height / 2,
                    width: annotation.width,
                    height: annotation.height
                });
            }
        });

        var ret = {
            key: converted.key,
            original: original,
            converted: converted
        };

        return {
            scaleAIUrl: scaleai.params.attachment,
            annotation: ret
        };
    });
};

var minMaxBox = function (box) {
    return {
        label: box.label,
        xmin: box.x - box.width / 2,
        xmax: box.x + box.width / 2,
        ymin: box.y - box.height / 2,
        ymax: box.y + box.height / 2
    };
};

var minMaxBack = function (bbox, originalBox) {
    var ret = {
        label: bbox.label,
        x: Math.round(bbox.xmin + bbox.xmax) / 2,
        y: Math.round(bbox.ymin + bbox.ymax) / 2,
        width: Math.round(bbox.xmax - bbox.xmin),
        height: Math.round(bbox.ymax - bbox.ymin)
    };

    if (originalBox.type) ret.type = originalBox.type;
    if (originalBox.points) ret.points = originalBox.points;

    return ret;
};

var convertHexToDouble = function (str) {
    var a = parseInt(str.substring(0, 8), 16);
    var b = parseInt(str.substring(8), 16);
    var e = (a >> 52 - 32 & 0x7ff) - 1023;
    var f = (a & 0xfffff | 0x100000) * 1.0 / Math.pow(2, 52 - 32) * Math.pow(2, e) + b * 1.0 / Math.pow(2, 52) * Math.pow(2, e);

    return f;
};

Annotation.scaleTo = function (converted, width, height) {
    if (!converted.width || !converted.height) return converted;

    var xScale = width / converted.width;
    var yScale = height / converted.height;

    _.each(converted.boxes, function (box) {
        box.x *= xScale;
        box.y *= yScale;
        box.width *= xScale;
        box.height *= yScale;

        _.each(box.points, function (point) {
            point[0] *= xScale;
            point[1] *= yScale;
        });
    });

    return converted;
};

Annotation.flip = function (converted, width, height) {
    _.each(converted.boxes, function (box) {
        if (box.flipY) {
            delete box.flipY;
            box.y = height - box.y;
        }
    });

    return converted;
};


Annotation.removeBadAnnotations = function (converted) {

    function _isNumber(value) {
        return typeof value === 'number' && isFinite(value);
    }

    var errors = [];

    var width = converted.width;
    var height = converted.height;

    var adjustedBoxes = [];
    _.each(converted.boxes, function (box) {
        const allNumbers = [box.x, box.y, box.width, box.height].every(_isNumber);
        if (!allNumbers || box.width < 0 || box.height < 0) {
            errors.push({
                type: 'error',
                code: 'annotation:invalid',
                key: _.isArray(converted.key) ? converted.key[0] : converted.key,
                label: box.label
            });
            return;
        }

        var bbox = minMaxBox(box);
        var scaled = false;
        var ONE = 1.010001; // account for floating point errors when multiplying by the image dimensions
        if (bbox.xmin <= ONE && bbox.xmax <= ONE && bbox.ymin <= ONE && bbox.ymax <= ONE && box.width <= ONE && box.height <= ONE) {
            // this is in percentage units; scale it up
            scaled = true;
            bbox.xmin *= width;
            bbox.xmax *= width;
            bbox.ymin *= height;
            bbox.ymax *= height;

            _.each(box.points, function (point) {
                point[0] *= width;
                point[1] *= height;
            });
        }

        if (bbox.xmax < 0 || bbox.xmin > width || bbox.ymax < 0 || bbox.ymin > height) {
            errors.push({
                type: 'error',
                code: 'annotation:outside',
                key: _.isArray(converted.key) ? converted.key[0] : converted.key,
                label: box.label
            });
            return;
        }

        var error = false;

        if (bbox.xmin < 0) {
            error = true;
            bbox.xmin = 0;
        }

        if (bbox.xmax > width) {
            error = true;
            bbox.xmax = width;
        }

        if (bbox.ymin < 0) {
            error = true;
            bbox.ymin = 0;
        }

        if (bbox.ymax > height) {
            error = true;
            bbox.ymax = height;
        }

        if (error || scaled) box = minMaxBack(bbox, box);

        if (error) {
            errors.push({
                type: 'warning',
                code: 'annotation:trimmed',
                key: _.isArray(converted.key) ? converted.key[0] : converted.key,
                label: box.label
            });
        }

        if (box.width == 0 || box.height == 0) {
            errors.push({
                type: 'warning',
                code: 'annotation:empty',
                key: _.isArray(converted.key) ? converted.key[0] : converted.key,
                label: box.label
            });
        }

        adjustedBoxes.push(box);
    });

    converted.boxes = adjustedBoxes;
    return errors;
};

Annotation.checkForMissingSequentialImages = function (images) {
    var names = [];

    _.each(images, function (image) {
        names.push(image.name);
    });
    names.sort();

    names = _.map(names, function (name) {
        return {
            name: name,
            num: parseInt(name.replace(/[^0-9]/g, ""))
        };
    });

    var warnings = [];

    for (var i = 1; i < names.length - 2; i++) {
        if (names[i - 1].num && names[i].num && names[i - 1].num + 2 == names[i].num) {
            warnings.push({
                type: 'warning',
                code: 'warning:sequential',
                key: names[i].name.replace(/[0-9]+/, names[i].num - 1)
            });
        }
    }

    return warnings;
};

Annotation.checkForTypoLabels = function (images) {
    var classes = {};
    _.each(images, function (image) {
        _.each(image.annotation && image.annotation.converted.boxes, function (box) {
            if (!classes[box.label]) classes[box.label] = 0;
            classes[box.label]++;
        });
    });

    var warnings = [];
    if (images.length < 10) return warnings;

    var cutoff = _.max(_.values(classes)) / 100;
    cutoff = Math.max(cutoff, _.size(images) / 100); // account for datasets with many labels per image
    cutoff = Math.ceil(cutoff);
    cutoff = Math.min(cutoff, 20); // if they have 20+ of them it's probably not a typo

    _.each(images, function (image) {
        _.each(image.annotation && image.annotation.converted.boxes, function (box) {
            if (classes[box.label] <= cutoff) {
                var converted = image.annotation.converted;
                warnings.push({
                    type: 'warning',
                    code: 'warning:typo',
                    key: _.isArray(converted.key) ? converted.key[0] : converted.key,
                    label: box.label
                });
            }
        });
    });

    return warnings;
};

var imagenetLabels;
Annotation.suggestCommonLabel = function (l) {
    if (!imagenetLabels) imagenetLabels = require(__dirname + "/metadata/classnames.imagenet.js");
    if (imagenetLabels[l]) {
        return {
            type: "ImageNet",
            original: l,
            options: imagenetLabels[l]
        };
    }

    return {
        type: "none",
        original: l,
        options: [l]
    };
};

Annotation.simplifyMultiPolygon = function (multiPolygon, simplification = 0.5, concavity = 1) {
    var left = Infinity;
    var right = -Infinity;
    var top = Infinity;
    var bottom = -Infinity;

    var originalPoints = [];
    _.each(multiPolygon, function (segmentation) {
        var distance, x, y, prev, dividers, newPoint;
        for (var i = 0; i <= segmentation.length - 2; i += 2) {
            x = segmentation[i];
            y = segmentation[i + 1];

            // make sure there are enough edge points along long lines that the
            // concave hull doesn't bust through too far by adding intermediary points
            prev = originalPoints[originalPoints.length - 1];
            if (!prev) {
                // if this is the first point, compare to the final point
                prev = [segmentation[segmentation.length - 2], segmentation[segmentation.length - 1]];
            }

            distance = Math.sqrt((prev[0] - x) * (prev[0] - x) + (prev[1] - y) * (prev[1] - y));

            dividers = Math.floor(distance / 5); // if the points are farther than 5 pixels apart, add some guides

            for (var j = 1; j < dividers; j++) {
                newPoint = [
                    prev[0] + (x - prev[0]) * j / dividers,
                    prev[1] + (y - prev[1]) * j / dividers
                ];
                originalPoints.push(newPoint);
            }

            originalPoints.push([x, y]);
        }
    });

    // get a concave hull & then simplify it to remove our added dividers
    var hull;
    if(concavity === 0) {
        // disable; used eg in smart polygon when you want complex shapes to be allowed
        hull = originalPoints;
    } else {
        hull = concaveman(originalPoints, concavity);
    }
    var simplifiedHull = simplify(_.map(hull, function(p) {
        return {
            x: p[0],
            y: p[1]
        };
    }), simplification, true);

    points = [];
    _.each(simplifiedHull, function (point) {
        if (point.x < left) left = point.x;
        if (point.x > right) right = point.x;
        if (point.y > bottom) bottom = point.y;
        if (point.y < top) top = point.y;

        points.push([point.x, point.y]);
    });

    return [points, {
        left: left,
        right: right,
        top: top,
        bottom: bottom,
        width: right - left,
        height: bottom - top,
        x: (left + right) / 2,
        y: (top + bottom) / 2
    }];
}

module.exports = Annotation;
